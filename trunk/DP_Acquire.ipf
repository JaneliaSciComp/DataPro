//	DataPro//	DAC/ADC macros for use with Igor Pro and the ITC-16 or ITC-18//	Nelson Spruston//	Northwestern University//	project began 10/27/1998//	last updated 6/12/2002#pragma rtGlobals=1		// Use modern global access method.//---------------------- DataPro Acquire STARTUP ----------------------//Function MakeADCDACWaves()	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	Variable xpnts=140//	make the dac and adc waves	Make/O/N=(xpnts) DACwave	Setscale x, 0, 0, "ms", DACwave	SetScale d 0, 0, "points", DACwave//	make FIFOin and FIFOout	Duplicate DACwave FIFOout	Duplicate DACwave FIFOin	//	now make ADCWave	Duplicate /O DACWave ADCwave	ADCWave=0//	SetScale d 0,0,unitsCurrent, ADCwave//	if (clamp_mode>0)//		SetScale d 0,0,unitsVoltage, ADCwave//	endif	SetScale d 0,0,"", ADCwave  // does this do anything?//	now make the test pulse DAC and ADC waves	Make /O/N=(xpnts) TestPulse_DAC	SetScale d 0,0,"points", TestPulse_DAC	Setscale x, 0, 0, "ms", TestPulse_DAC	Duplicate /O TestPulse_DAC TestPulse_ADC//	now make the data pulse DAC and ADC waves	Make /O/N=(xpnts) StepPulse_DAC	SetScale d 0,0,"points", StepPulse_DAC	Setscale x, 0, 0, "ms", StepPulse_DAC	Duplicate /O StepPulse_DAC StepPulse_ADC	Duplicate /O StepPulse_DAC SynPulse_TTL//	make waves for pulse builder	Make /O/N=1000 Step5DAC, TrainDAC, RampDAC, PSCDAC, SineDAC, NewDAC	Make /O/N=5 amplitude, duration	Variable /G stepdur0, stepdur1, stepdur2, stepdur3, stepdur4	Variable /G stepamp0, stepamp1, stepamp2, stepamp3, stepamp4, sintpb	stepdur0=10; stepdur1=10; stepdur2=10; stepdur3=10; stepdur4=10	stepamp1=10; stepamp3=10; sintpb=0.01	Variable /G traindur0, traindur1, traindur2, trainnum, trainfreq, trainamp, trainbase, traindur	traindur0=10; traindur1=10; traindur2=10; trainnum=10	trainfreq=10; trainamp=10; trainbase=0; traindur=2	Variable /G rampdur1, rampdur2, rampdur3, rampdur4, rampamp1, rampamp2, rampamp3, rampamp4	rampdur1=10; rampdur2=50; rampdur3=10; rampdur4=10; rampamp1=-10; rampamp2=0; rampamp3=10; rampamp4=0	Variable /G pscdur0, pscdur1, pscdur2, pscamp, psctaur, psctaud1, psctaud2, wttd2	pscdur0=10; pscdur1=50; pscdur2=10; pscamp=10; psctaur=0.2; psctaud1=2; psctaud2=10; wttd2=0.5	Variable /G sinedur0, sinedur1, sinedur2, sineamp, sinefreq	sinedur0=10; sinedur1=50; sinedur2=10; sineamp=10; sinefreq=100//	for PN subtraction	Variable /G pn	pn=-4//	check for error condition	Variable /G error//	make average wave for imaging	//NewDataFolder /O/S root:DP_Imaging	//Make /N=(imageavgn) dff_avg//	return to default folder	SetDataFolder savDFEndFunction SetupGlobals()//	Acquisition globals//	USERS SHOULD NOT EDIT ANYTHING HERE//	EDIT ONLY IN THE DP5_MyVariables FILE	PauseUpdate; Silent 1	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol//	if (DataFolderExists("DP_ADCDACcontrol"))//		SetDataFolder DP_ADCDACcontrol//	else//		NewDataFolder /S DP_ADCDACcontrol//	endif//	Current and voltage units	String /G unitsCurrent, unitsVoltage//	ITC and usPerDigitizerClockTick	Variable /G itc, usPerDigitizerClockTick//	itc=16; usPerDigitizerClockTick=1.0	itc=18; usPerDigitizerClockTick=1.25//	set up some dac and adc variables	Variable /G nADCInUse=1			// number of ADC channels we're using	Variable /G nDACInUse=1			// number of DAC channels we're using//	Variables for dac and adc gains	//Variable /G dac_current, dac_voltage, adc_current, adc_voltage	//Variable /G dacgain0, dacgain1, dacgain2, dacgain3	//Variable /G dacgain0_current, dacgain1_current, dacgain2_current, dacgain3_current	//Variable /G dacgain0_voltage, dacgain1_voltage, dacgain2_voltage, dacgain3_voltage	Variable /G multdac, multdac0, multdac1, multdac2, multdac3, multdacD	//Variable /G adcgain0, adcgain1, adcgain2, adcgain3, adcgain4, adcgain5, adcgain6, adcgain7 	//Variable /G adcgain0_current, adcgain1_current, adcgain2_current, adcgain3_current, adcgain4_current, adcgain5_current, adcgain6_current, adcgain7_current 	//Variable /G adcgain0_voltage, adcgain1_voltage, adcgain2_voltage, adcgain3_voltage, adcgain4_voltage, adcgain5_voltage, adcgain6_voltage, adcgain7_voltage //	global variables for the test pulse	Variable /G tpamp, tpdur, tpgate, tpgateamp//	global variables for DAC waves	Variable /G ffseg=1	Variable /G sintdisp=0.01//	global variables for the data wave	Variable /G iSweep=1		// index of the current/next sweep to be acquired	//Variable /G iSweepPrevious=0	Variable /G dpamp, dpdur, dplow, dphigh, dpshort, dplong//	globals for the FIFO	Variable /G fifopts, fifoptsmult//	globals for synaptic stimulation	Variable /G syntime, syndur//	For repeated stimulation	Variable /G nSweepsPerTrial=1, sweep_interval=10//	For comments	String /G wave_comments	// initial type of ADC, DAC channels (currently can be 1==current or 2==voltage	Make /O /N=8 adcType	adcType={2,2,2,2,2,2,2,2}		// all voltage channels	Make /O /N=4 dacType	dacType={1,1,1,1}		// all current channels 	//Variable /G dacout=0	//Variable /G adcin=0//	Make waves for adc and dac gains	Make /O/N=8 adcgain, adcgain_current, adcgain_voltage	Make /O/N=4 dacgain, dacgain_current, dacgain_voltage//	adcgain=0//	dacgain=0	//Vars2Wave("dacgain","dacgain",4)	//Vars2Wave("adcgain","adcgain",8)	dacgain_current=dacgain; dacgain_voltage=dacgain	adcgain_current=adcgain; adcgain_voltage=adcgain//	string variables for adc in wave names	String /G adcname0, adcname1, adcname2, adcname3	String /G adcname4, adcname5, adcname6, adcname7	Make /O/T/N=8 adcname	adcname={"ad0_","ad1_","ad2_","ad3_","ad4_","ad5_","ad6_","ad7_"}	Wave2StringVars("adcname","adcname",8)//	global variables for the sample interval	Variable /G sinttp, sintdp, sint	sinttp=0.02	// default sample interval for the test pulse	sintdp=0.05	// default sample interval for the data pulse	sint=0.05		// final sample interval//	global variables and strings for the sample sequence	Variable /G seqlength	String /G daseq, adseq//	Make waves to read which adc/dac/ttl devices should be on	Make /O/N=8 adcon, dacon, ttlon	adcon[0]=1		// turn on ADC 0 by default	dacon[0]=1		// turn on DAC 0 by default//	now assign some other variables	Variable /G baseline_sub, tpscale, rseal, testadc, testdac	Variable /G pointsPerVoltADC=32768/10.24		// How many volts at the ADC correspond to a 1 bit change in the least significant bit	Variable /G pointsPerVoltDAC=32768/10.24		// How many volts does the DAC output change in response to a 1 bit change in the least significant bit	//Variable /G useadcgain, usedacgain	//Variable /G outgain	//Variable /G ingain	baseline_sub=1; testadc=0; testdac=3; tpscale=1	Variable /G autoAnalyzeChecked=0		// true iff AutoAnalyze checkbox is checked	String /G thiswave////	DATA_PRO BROWSER GLOBALS//	NewDataFolder /O/S root:DP_Browser////	globals for axis scaling//	Variable /G ymin, ymax, xmin, xmax//	Variable /G acsrx, bcsrx//	ymax=3; ymin=-3; xmin=0; xmax=100; acsrx=0; bcsrx=0//	String /G topTraceWaveName, thiswave//	Variable /G nswps, tswps//	//Variable /G iOldSweep, //	Variable /G iCurrentSweep=1//	Variable /G v_left, v_right, v_bottom, v_top//	Variable /G acsrx, bcsrx//	Variable /G base, mean1, peak1, rise1, from1, to1//	Variable /G mean2, peak2, rise2, from2, to2, lev1, nCrossings1//	Variable /G mean_left, mean_right, tWindow1Left, tWindow1Right, tWindow2Left, tWindow2Right//	Variable /G  amp1, tau1, amp2, tau2, yOffset, dtFitExtend, numChannels//	numChannels=1//	Variable /G tFitZero, tFitLeft, tFitRight, firstwave, lastwave//	String /G baseNameA, baseNameB, traceAWaveName, traceBWaveName//	//String /G oldWave1Name, oldWave2Name//	//String /G oldbname1, oldbname2//	String /G avgname1, avgname2, avgprompt, destwave//	Variable /G history=0//	String /G comments//	Variable /G baselineA, step1, baselineB, step2//	baseNameA=root:DP_ADCDACcontrol:adcname0//	baseNameB=root:DP_ADCDACcontrol:adcname1//	avgname1=baseNameA//	avgname2=baseNameB//	//oldbname1=baseNameA//	//oldbname2=baseNameB////	Make waves for colors//	Variable /G red, green, blue//	Make /O/N=(8,3) Colors//	Colors[][0]={0,65535,3,29524,4369,39321,65535}//	Colors[][1]={0,0,52428,1,4369,26208,0}//	Colors[][2]={65535,0,1,58982,4369,1,26214}////	IMAGING GLOBALS//	NewDataFolder /O/S root:DP_Imaging//	String /G all_images//	Variable /G fluo_on_wheel, fluo_off_wheel//	fluo_on_wheel=1; fluo_off_wheel=0//	Variable /G sidx_handle//	Variable /G ccd_opened, ccd_setup 	// ccd_setup may be unnecessary since SIDX_Setup is called often////	Variable ccd_driver, ccd_hardware, ccd_camera//	Variable /G image_trig, image_focus, image_roi // image_focus may be unnecessary if there is a separate focus routine//	Variable /G imaging, ccd_handle, ccd_tempset, ccd_temp, ccd_frames//	ccd_tempset=-20; ccd_frames=56//	Variable /G ccd_focusexp, ccd_fullexp, ccd_seqexp, imageavgn, im_plane//	ccd_focusexp=100; ccd_fullexp=100; ccd_seqexp=50; imageavgn=0//	String /G full_name, focus_name, imageseq_name, gstack, gimage//	full_name="full_"; focus_name="full_"; imageseq_name="trig_"//	Variable /G full_num, focus_num, imageseq_num//	full_num=1; focus_num=1; imageseq_num=1//	Variable /G numrois, roinum, roi_left, roi_right, roi_top, roi_bottom, xbin, ybin, xpixels, ypixels//	numrois=2; roinum=1; roi_left=200; roi_right=210; roi_top=200; roi_bottom=220//	xbin=10; ybin=20; xpixels=(roi_right-roi_left)/xbin; ypixels=(roi_bottom-roi_top)/ybin//	Variable /G gray_low, gray_high//	gray_low=0; gray_high=64000//	Make/O/N=(6,numrois+1)/I roiwave//	roiwave[][1]={roi_left, roi_right, roi_top, roi_bottom, xbin, ybin}//	roiwave[][2]={roi_left, roi_right, roi_top, roi_bottom, xbin, ybin}//	Make /O/N=(5,numrois+1)/I roibox_x roibox_y//	roibox_x[][1]={roi_left, roi_right, roi_right, roi_left, roi_left}//	roibox_y[][2]={roi_top, roi_top, roi_bottom, roi_bottom, roi_top}//	Make /O/N=5 roibox_x1, roibox_y1, roibox_x2, roibox_y2//	ANALYSIS GLOBALS//	NewDataFolder /O/S root:DP_Analysis//	Variable /G iSweepFirstAverage, iSweepLastAvg, avghold, stepToAverage, holdtolerance	// averaging globals//	Variable /G slope_left, slope_right, ltp_interval	//	globals for LTP//	RETURN TO DEFAULT FOLDER	SetDataFolder savDFEndFunction SetupGlobalsPostUser()	// USERS SHOULD NOT EDIT THIS FUNCTION	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		NVAR itc,usPerDigitizerClockTick	WAVE adcType,dacType	//NVAR dacgain0_current,dacgain1_current,dacgain2_current,dacgain3_current	//NVAR dacgain0_voltage,dacgain1_voltage,dacgain2_voltage,dacgain3_voltage	//NVAR adcgain0_current,adcgain1_current,adcgain2_current,adcgain3_current	//NVAR adcgain4_current,adcgain5_current,adcgain6_current,adcgain7_current	//NVAR adcgain0_voltage,adcgain1_voltage,adcgain2_voltage,adcgain3_voltage	//NVAR adcgain4_voltage,adcgain5_voltage,adcgain6_voltage,adcgain7_voltage	//NVAR adcgain0,adcgain1,adcgain2,adcgain3	//NVAR adcgain4,adcgain5,adcgain6,adcgain7	//NVAR dacgain0,dacgain1,dacgain2,dacgain3	WAVE adcgain, dacgain	WAVE dacgain_current, adcgain_current, dacgain_voltage, adcgain_voltage		if (itc<18)		usPerDigitizerClockTick=1	// 1 usec for itc16	else		usPerDigitizerClockTick=1.25	// 1.25 usec for itc18	endif		String commandLine	Variable i	for (i=0; i<8; i=i+1)		if (adcType[i]==1)			// current channel			adcgain[i]=adcgain_current[i]		else			// voltage channel			adcgain[i]=adcgain_voltage[i]		endif	endfor	for (i=0; i<4; i=i+1)		if (dacType[i]==1)			// current channel			dacgain[i]=dacgain_current[i]		else			// voltage channel			dacgain[i]=dacgain_voltage[i]		endif	endfor	//dacgain_current={dacgain0_current, dacgain1_current, dacgain2_current, dacgain3_current}	//adcgain_current={adcgain0_current, adcgain1_current, adcgain2_current, adcgain3_current, adcgain4_current, adcgain5_current, adcgain6_current, adcgain7_current}	//dacgain_voltage={dacgain0_voltage, dacgain1_voltage, dacgain2_voltage, dacgain3_voltage}	//adcgain_voltage={adcgain0_voltage, adcgain1_voltage, adcgain2_voltage, adcgain3_voltage, adcgain4_voltage, adcgain5_voltage, adcgain6_voltage, adcgain7_voltage}	SetDataFolder savDFEnd//_______________________DataPro TEST PULSE MACROS_________________________//Function BuildTestPulse()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	NVAR sinttp=sinttp, tpgate=tpgate, tpamp=tpamp, tpdur=tpdur, usPerDigitizerClockTick	WAVE amplitude=amplitude, duration=duration	Variable numsegs, sintms, sintpts, first, last, totaldur, xpnts, i	numsegs=3//	Make /O/N=(numsegs) amplitude, duration	amplitude=0	duration=2	// user contolled variables	// amplitudes have units specified in unitsCurrent/unitsVoltage; 	// durations and sample interval have units of ms	sintms=sinttp					// sample interval (ms)	DoWindow /F TestPulsePanel	ControlInfo tpgate_check	if (V_value>0)		amplitude[1]=tpgate		// amplitude of second segment for gate mode	else		amplitude[1]=tpamp		// amplitude of second segment	endif	duration[0]=0.5*tpdur		// duration of first segment (ms)	duration[1]=tpdur			// duration of second segment (ms)	duration[2]=0.5*tpdur		// duration of third segment (ms)//	fixed and calculated variables	sintpts=sintms*1000/usPerDigitizerClockTick	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<numsegs)	xpnts=totaldur/sintms	Make /O/N=(xpnts) TestPulse_DAC	Wave TestPulse_DAC=TestPulse_DAC	Setscale x, 0, totaldur, "ms", TestPulse_DAC	first=0	last=duration[0]/sintms	i=0	do		TestPulse_DAC[first,last]=amplitude[i]		first=last+1		last=first+duration[i+1]/sintms-1		i+=1	while(i<numsegs)	SetDataFolder savDFEndFunction StartTestPulse()//	called by Start button in Test Pulse Window only	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable  testtrigger, testtrigttl, miny, maxy	testtrigger=1; testtrigttl=2	if (wintype("TestPulseDisplay")<1)		TestPulseDisplay()	endif	DoWindow /F TestPulsePanel	SetTPvalues()	BuildTestPulse()	WAVE TestPulse_DAC	WAVE TestPulse_ADC	WAVE TestTrig_TTL	WAVE FIFOout	WAVE FIFOin	Duplicate /O TestPulse_DAC FIFOout, FIFOin, TestPulse_ADC, TestTrig_TTL	NVAR testdac	//outgain=SetDACGain(testdac)	Variable outgain=ComputeOutputGain(testdac)	NVAR testadc	//SyncADCGainWaveToVars()	Variable ingain=ComputeInputGain(testadc)	SVAR daseq	daseq=num2str(testdac)	SVAR adseq	adseq=num2str(testadc)	//outgain=SetDACGain(testdac)	NVAR sinttp	if (testtrigger>0)		daseq+="D"		adseq+=num2str(testadc)		TestTrig_TTL=0		TestTrig_TTL[1,11]=2^testtrigttl		Make /O/N=(numpnts(TestPulse_DAC)*2) FIFOout, FIFOin		Setscale /P x, 0, sinttp/2, "ms", FIFOout, FIFOin		// revise to reflect length of daseq // also this should happen also for no trigger //		FIFOout[0,;2]=TestPulse_DAC[p/2]*outgain		FIFOout[1,;2]=TestTrig_TTL[p/2]	else		FIFOout=TestPulse_DAC*outgain	endif	Variable x1, x2, x3, x4, base, pulse	x1=1	x2=round(0.98*numpnts(TestPulse_ADC)/8)	x3=round(5*numpnts(TestPulse_ADC)/8)	x4=round(6*numpnts(TestPulse_ADC)/8)-1	x1=pnt2x(TestPulse_ADC,x1)	x2=pnt2x(TestPulse_ADC,x2)	x3=pnt2x(TestPulse_ADC,x3)	x4=pnt2x(TestPulse_ADC,x4)	DoWindow /F TestPulseDisplay		PauseUpdate//	execute the sample sequence	SampleData()//	extract waves from FIFOin	if (testtrigger>0)		TestPulse_ADC=FIFOin[2*p]*ingain	else		TestPulse_ADC=FIFOin*ingain	endif	ControlInfo /W=DataAcqPanel tp_bsub	if (V_value>0)		Wavestats /Q/R=[5,45] TestPulse_ADC		TestPulse_ADC-=V_avg	endif//	set display range//	Wavestats /Q/R=(x1,x2) TestPulse_ADC	Wavestats /Q TestPulse_ADC	miny=1.2*V_min//	Wavestats /Q/R=(x3,x4) TestPulse_ADC	Wavestats /Q TestPulse_ADC	maxy=1.2*V_max	miny-=maxy/10	if (miny>-0.2)		miny=-0.2	endif	if (maxy<0.2)		maxy=0.2	endif	Setaxis left, miny, maxy	ModifyGraph grid(left)=1	ModifyGraph tickUnit(bottom)=1	Label bottom "\\F'Helvetica'\\Z12\\f01Time (ms)"	WAVE adcType, dacType	SVAR unitsCurrent, unitsVoltage	if (adcType[testadc]==1)		Label left sprintf1s("\\F'Helvetica'\\Z12\\f01Current (%s)",unitsCurrent)	else		Label left sprintf1s("\\F'Helvetica'\\Z12\\f01Voltage (%s)",unitsVoltage)	endif	NVAR rseal, tpamp	do		//PauseUpdate		SampleData()		if (testtrigger>0)			TestPulse_ADC=FIFOin[2*p]*ingain//			Setscale /P x, 0, sinttp, "ms", FIFOout, FIFOin		else			TestPulse_ADC=FIFOin*ingain		endif		ControlInfo /W=DataAcqPanel tp_bsub		if (V_value>0)			Wavestats /Q/R=[5,45] TestPulse_ADC			TestPulse_ADC-=V_avg		endif		base=mean(TestPulse_ADC,x1,x2)		pulse=mean(TestPulse_ADC,x3,x4)		if (adcType[testadc]==1 && dacType[testdac]==2)			// ADC channel is a current channel, DAC channel is a voltage channel			rseal=tpamp/(pulse-base)		elseif (adcType[testadc]==2 && dacType[testdac]==1)			// output channel is a voltage channel			rseal=(pulse-base)/tpamp		else			Printf "ADC and DAC channel for tet pulse are of same type, therefore the 'resistance' is unitless!\r"			rseal=nan		endif		DoUpdate	while (HaltProcedures()<1)	DoWindow /F TestPulsePanel	SetDataFolder savDFEndFunction TPWinButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("TestPulseDisplay")<1)		Execute "TestPulseDisplay()"	else		DoWindow /F TestPulseDisplay		endif	if (wintype("DataAcqPanel")<1)		Execute "DataAcqPanel()"	else		DoWindow /F DataAcqPanel		endif	SetTPValues()EndFunction TPStartButtonProc(ctrlName) : ButtonControl	String ctrlName	StartTestPulse()EndFunction BsubCheck(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checkedEndFunction TPgateCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	if (checked<1)		checked=1	else		checked=0	endif	SetTPvalues()	BuildTestPulse()EndFunction TPampProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	SetTPvalues()	BuildTestPulse()EndFunction SetTPvalues()	NVAR tpamp=tpamp, tpgateamp=tpgateamp, tpdur=tpdur	ControlInfo tpgate_check	if (V_value>0)		tpamp=tpgateamp	endifEnd//_______________________DataPro DATA ACQUISITION MACROS_________________________//Function BuildStepPulse()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable numsegs, sintms, sintpts, first, last, totaldur, xpnts, i	WAVE amplitude, duration	NVAR usPerDigitizerClockTick, sintdp, dpamp, dpdur	numsegs=3//	Make /O/N=(numsegs) amplitude, duration	amplitude=0	duration=2//	user contolled variables//	amplitudes have units specified by unitsCurrent, unitsVoltage//	durations and sample interval have units of ms	sintms=sintdp				// sample interval (ms)	amplitude[1]=dpamp		// amplitude of second segment	duration[0]=0.2*dpdur		// duration of second segment (ms)	duration[1]=dpdur			// duration of second segment (ms)	duration[2]=0.5*dpdur		// duration of second segment (ms)//	fixed and calculated variables	sintpts=sintms*1000/usPerDigitizerClockTick	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<numsegs)	xpnts=totaldur/sintms	Make /O/N=(xpnts) StepPulse_DAC	Setscale x, 0, totaldur, "ms", StepPulse_DAC	Note /K StepPulse_DAC	ReplaceStringByKeyInWaveNote(StepPulse_DAC,"WAVETYPE","step3dac")	ReplaceStringByKeyInWaveNote(StepPulse_DAC,"TIME",time())	ReplaceStringByKeyInWaveNote(StepPulse_DAC,"STEP",num2str(amplitude[1]))	StepPulse_DAC=0	first=0	i=0	do		last=first+(duration[i]-sintms)/sintms		StepPulse_DAC[first,last]=amplitude[i]		first=last+1		i+=1	while(i<numsegs)	SetDataFolder savDFEndFunction BuildSynTTLPulse()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable first, last, sintms	NVAR syntime=syntime, syndur=syndur	Duplicate /O StepPulse_DAC SynPulse_TTL	Note /K SynPulse_TTL	ReplaceStringByKeyInWaveNote(SynPulse_TTL,"WAVETYPE","synttl")	ReplaceStringByKeyInWaveNote(SynPulse_TTL,"TIME",time())	SynPulse_TTL=0	sintms=deltax(SynPulse_TTL)	first=syntime/sintms	last=first+syndur/sintms	SynPulse_TTL[first,last]=1	SetDataFolder savDFEndFunction BuildFIFOwaves()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable dac, firsttime, i, wpts	WAVE ttlon=ttlon	SVAR thiswave=thiswave, daseq=daseq	NVAR sint=sint, fifopts=fifopts, nADCInUse, fifoptsmult=fifoptsmult	NVAR seqlength=seqlength, multdac=multdac, error=error	String pop, S_value, command, notestr, mdstr	if (!PanelExists("ADCDACControl"))		error=1		Abort "You need to open the ADC/DAC control panel first. Once it's open, you can hide it by double clicking the top bar."	endif//	first build a single TTL pulse wave//	parent TTL waves should consist of zeros (low) and ones (high) only	firsttime=0	i=0	do		if (ttlon[i]>0)			sprintf pop "ttlpopup_%d", i			ControlInfo /W=ADCDACControl $pop			thiswave=S_value				if (cmpstr(thiswave,"_none_")==0)					Abort "You need to choose a TTL wave if you want an output on this channel."				endif			if (firsttime<1)				Duplicate /O $thiswave TTLoutwave				TTLoutwave=(2^i)*TTLoutwave				sint=deltax(TTLoutwave)				//	calculate the multiplier for the number of points in the FIFO waves				wpts=numpnts(TTLoutwave)//				fifopts=nADCInUse*wpts//				fifoptsmult=fifopts/wpts	// = nADCInUse				fifoptsmult=strlen(daseq)				fifopts=fifoptsmult*wpts				// 	make the FIFO waves				Make /O/N=(fifopts) FIFOout FIFOin				FIFOout=0				FIFOin=0				firsttime=1			else				WAVE newwave=$thiswave				TTLoutwave+=(2^i)*newwave			endif		endif		i+=1	while(i<4)//	now assign values to FIFOout according to daseq	Variable outgain	i=0	do		dac=str2num(daseq[i])		if (dac<4)			sprintf pop "dacpopup_%d",dac			ControlInfo /W=ADCDACControl $pop			thiswave=S_value			//SetDACgain(dac)			outgain=ComputeOutputGain(dac)		else			thiswave="TTLoutwave"			outgain=1		endif		if (cmpstr(thiswave,"_none_")==0)			FIFOout[i,;seqlength]=0		else			if (firsttime<1)				sint=deltax($thiswave)				//	calculate the multiplier for the number of points in the FIFO waves				wpts=numpnts($thiswave)				fifopts=nADCInUse*wpts					//////////////////////////////////  fix ??? ////////////////////////				fifoptsmult=fifopts/wpts					//////////////////////////////////  fix ??? ////////////////////////				// 	make the FIFO waves				Make /O/N=(fifopts) FIFOout FIFOin				FIFOout=0				FIFOin=0				firsttime=1			else				if (sint!=deltax($thiswave))					Beep					Abort "There is a sample interval mismatch in your DAC waves."				endif				if (wpts!=numpnts($thiswave))					Beep					Abort "There is a mismatch in the number of points in your DAC and/or TTL waves."				endif			endif//			sprintf command, "multdac=multdac%s", daseq[i]//			Execute command			sprintf mdstr, "multdac%s", daseq[i]			NVAR mdval=$mdstr, multdac=multdac			multdac=mdval			Wave thewave=$thiswave			FIFOout[i,;seqlength]=thewave[floor(p/fifoptsmult)]*outgain*multdac		endif		i+=1	while(i<seqlength)	Setscale /P x, 0, sint/fifoptsmult, "ms", FIFOout, FIFOin	Note /K FIFOin	ReplaceStringByKeyInWaveNote(FIFOin,"WAVETYPE","adc")	ReplaceStringByKeyInWaveNote(FIFOin,"TIME",time())	String newFIFOStepValue=StringByKeyInWaveNote($thiswave,"STEP")	ReplaceStringByKeyInWaveNote(FIFOin,"STEP",newFIFOStepValue)	SetDataFolder savDFEndFunction AcquireSweep()	// Acquire a single sweep, which consists of n traces, each trace corresponding to a single ADC channel	Silent 1	Wave browserNumber=GetAllBrowserNumbers()  // returns a free wave	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String /G savename	String thisstr, doit, whichadc	Variable leftmin, leftmax	//NVAR imaging=root:DP_Imaging:imaging	NVAR iSweep	NVAR nADCInUse	//NVAR iSweepPrevious	NVAR sint	NVAR fifoptsmult, pn	NVAR error	SVAR adseq	SVAR wave_comments	SVAR thisWaveNameRel=thiswave	WAVE FIFOin, FIFOout, adcname	NVAR autoAnalyzeChecked		DoWindow /F DataAcqPanel	//	SetDPvalues()	MakeITCseq()	BuildStepPulse()	BuildSynTTLPulse()	BuildFIFOwaves()	if (error>0)		error=1		Abort "data acquisition terminated"	endif		// Actually acquire the data for this sweep	SampleData() 		// Do pN Subtraction, if called for	ControlInfo pn_check	if (V_value>0)		Duplicate /O FIFOout PNout		Duplicate /O FIFOin PNin		PNout=FIFOout/pn		FIFOout=PNout		Variable i		for (i=0; i<abs(pn); i+=1)			SampleData()			if (pn<0)				PNin+=FIFOin			else				PNin-=FIFOin			endif		endfor		FIFOin=PNin	endif		//// Bring the DP Browsers forward	Variable nBrowsers=numpnts(browserNumber)	for (i=0;i<nBrowsers;i+=1)		String browserNameThis=BrowserNameFromNumber(browserNumber[i])		DoWindow /F $browserNameThis	endfor		//String browserName=BrowserNameFromNumber(browserNumber)	//DoWindow /F $browserName		// Extract individual traces from FIFOin, store them in the appropriate waves	String nameOfVarHoldingADCWaveBaseName, units	Variable iADCChannel		// index of the relevant ADC channel	WAVE adcType	// wave s.t. adcType[i] gives the channel type-code for ADC i	SVAR unitsCurrent, unitsVoltage	Variable ingain	Variable iTrace	for (iTrace=0; iTrace<nADCInUse; iTrace+=1)		SetDataFolder root:DP_ADCDACcontrol  // added by ALT 2012-05-23			// Must be here for adc1, adc2, etc. to get saved to waves with the right names		iADCChannel=str2num(adseq[iTrace])		ingain=ComputeInputGain(iADCChannel)		sprintf nameOfVarHoldingADCWaveBaseName "adcname%d", iADCChannel		SVAR base=$nameOfVarHoldingADCWaveBaseName		sprintf thisWaveNameRel "%s%d", base, iSweep		sprintf savename "%s.bwav", thisWaveNameRel		SetDataFolder root:		Make /O/N=(numpnts(FIFOin)/nADCInUse) $thisWaveNameRel		String thisWaveNameAbs="root:"+thisWaveNameRel		WAVE thisWave=$thisWaveNameAbs		Note thisWave, note(FIFOin)	// copy the wave note from FIFOin to the destination wave		thisWave=FIFOin[fifoptsmult*p+iTrace]*ingain		Setscale /P x, 0, sint, "ms", thisWave		if (adcType[iADCChannel]==1)			// current channel			units=unitsCurrent		else			// voltage channel			units=unitsVoltage		endif					SetScale d 0,0,units, thisWave		ReplaceStringByKeyInWaveNote(thisWave,"COMMENTS",wave_comments)		Save /O /P=home thisWave as savename	endfor	// This needs to be smarter, since we don't know what traces they are showing 	// in the DP browser.	////	// Make sure the traces are shown if they were acquired//	if ( nADCInUse>=1 )//		SetTraceAChecked(browserNumber,1)//	endif//	if ( nADCInUse>=2 )//		SetTraceBChecked(browserNumber,1)//	endif		// Update the sweep number in the DP Browsers	for (i=0;i<nBrowsers;i+=1)		SetICurrentSweepAndSyncView(browserNumber[i],iSweep)	endfor		// Update some of the acquisition counters	iSweep+=1	//iSweepPrevious=iSweep-1		// Bring the data acquistion panel forward, for some reason	DoWindow /F DataAcqPanel			// Update the windows, so user can see the new sweep	DoUpdate	// If called for, run the per-user function	if (autoAnalyzeChecked)		AutoAnalyze()		DoUpdate	endif	// Restore the original data folder	SetDataFolder savDFEnd//Function EPhys_Image()//	Variable sidx_handle, status, exposure, canceled//	String message, command//	if (ccd_opened<1)//		SIDX_Begin()//	endif////	if (sidx_handle==  4.306e+07)////		SIDX_Begin_Auto()////	endif////	SIDX_Setup()//	image_trig=1//	SIDX_Setup_Auto()//	image_roi=2		// zero for full frame, one for specific ROI, two for ROI with background//	im_plane=0//	FluorescenceON()//	Execute "Sleep /S 0.1"//	sprintf command, "Image_Stack(image_trig,0)"//	Execute command//	print "done with image stack"//	sprintf command, "Get_DFoverF_from_Stack(%d)", iSweepPrevious//	Execute command//	sprintf command, "Append_DFoverF(%d)", iSweepPrevious//	Execute command//	FluorescenceOFF()//	printf "%s%d: Image with EPhys done\r", imageseq_name, iSweepPrevious//EndFunction DataButtonProc(ctrlName) : ButtonControl	// Raise or create the three windows used for data acquisition	String ctrlName		Execute "RaiseOrCreatePanel(\"ADCDACControl\")"	Execute "RaiseOrCreatePanel(\"DataAcq\")"	Execute "RaiseOrCreateDataProBrowser()"EndFunction DataAcqButtonProc(ctrlName) : ButtonControl	String ctrlName	AcquireTrial()EndFunction AcquireTrial()	// Acquire a single trial, which is composed of n sweeps	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	Variable start_time, last_time	String temp_comments, doit	NVAR nSweepsPerTrial	NVAR sweep_interval	NVAR error	SVAR wave_comments	Variable iSweepWithinTrial	for (iSweepWithinTrial=0;iSweepWithinTrial<nSweepsPerTrial; iSweepWithinTrial+=1)			if (iSweepWithinTrial<1)			start_time = DateTime		else			start_time = last_time + sweep_interval		endif		if (nSweepsPerTrial==1)			sprintf wave_comments "stim %d of %d",iSweepWithinTrial+1,nSweepsPerTrial		else			sprintf wave_comments "stim %d of %d, with inter-stim-interval of %d",iSweepWithinTrial+1,nSweepsPerTrial,sweep_interval		endif		sprintf doit, "Sleep /A %s", Secs2Time(start_time,3)		Execute doit		AcquireSweep()  // this calls DoUpdate() inside		if (error>0)			error=0			Abort 		endif		last_time = start_time		SaveStimHistory()	endfor	wave_comments=""	SetDataFolder savDFEndFunction DPampProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName//	SetDPvalues()	BuildStepPulse()EndFunction DPdurCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	if (cmpstr(ctrlName,"dpdur_check0")!=0)		CheckBox dpdur_check0 value=0		CheckBox dpdur_check1 value=1	else		CheckBox dpdur_check1 value=0		CheckBox dpdur_check0 value=1	endif//	SetDPvalues()	BuildStepPulse()EndFunction DPdurProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName//	SetDPvalues()	BuildStepPulse()End//______________________DataPro Imaging PROCEDURES__________________________//Function ImagingButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("ImagingPanel")<1)		Execute "ImagingPanel()"	else		DoWindow /F ImagingPanel		endifEndFunction FluONButtonProc(ctrlName) : ButtonControl	String ctrlName	FluorescenceON()EndFunction FluorescenceON()	String command	NVAR wheel=fluo_on_wheel	SetVDTPort("COM1")	Execute "VDTWriteBinary 238"	sprintf command "VDTWriteBinary 8%d", wheel	Execute command//	print "fluorescence on"EndFunction FluOFFButtonProc(ctrlName) : ButtonControl	String ctrlName	FluorescenceOFF()EndFunction FluorescenceOFF()	SetVDTPort("COM1")	Execute "VDTWriteBinary 238"	Execute "VDTWriteBinary 80"//	print "fluorescence off"EndFunction SetVDTPort(name)	String name	Execute "VDTGetPortList"	SVAR port=S_VDT	NVAR imaging=imaging	String command	imaging=1	if (cmpstr(port,"")==0)		imaging=0		Abort "A serial port could not be located"	else		sprintf command, "VDTOperationsPort %s", name		Execute command	endifEndFunction ImagingCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	NVAR imaging=imaging	Execute "VDTGetPortList"	SVAR port=S_VDT	if (checked>0)		imaging=1		SetVDTPort("COM1")	else		imaging=0	endifEnd//______________________DataPro Data Acquisition HISTORY__________________________////________________________written by Don Cooper________________________________//Function SaveStimHistory()	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	Variable StimHsize, wavenum	String theMultDac, theDacGain, theDacPopup	NVAR nSweepsPerTrial	NVAR iSweep=iSweep, multdac1=multdac1, HoldV=HoldV,NumRepeats=NumRepeats, IStimI=IStimI, TempV=TempV, Rseal=Rseal	NVAR MadeStimHist=MadeStimHist, dacgain1=dacgain1, dpamp=dpamp, dpdur=dpdur, multdac2=multdac2	NVAR dacgain2=dacgain2, pn=pn	SVAR wave_comments=wave_comments, daseq=daseq//	String history="StimHistory"//  ***daseq*** = string listing which DAC's are checked               sprintf theMultDac "multdac%s", daseq[0]     sprintf theDacGain "dacgain%s", daseq[0]     sprintf theDacPopup "dacpopup_%s", daseq[0]     NVAR theMD=$theMultDac, theDG=$theDacGain     wavenum=iSweep-1// make a table... but check to see if it's already been made first	if (exists("StimHistory")!=1)		Make/T/O/N=(2,11) StimHistory		StimHistory[0][0]="Stimulus Wave"		StimHistory[0][1]="Wave Multiplier"		StimHistory[0][2]="Holding Potential"		StimHistory[0][3]="Gain"		StimHistory[0][4]="Current Step"		//for step_pulses		StimHistory[0][5]="Step Duration"		//for step_pulses		StimHistory[0][6]="pN"		StimHistory[0][7]="Comments"		StimHistory[0][8]="Time"		StimHistory[0][9]="Temp"		Stimhistory[0][10]="Seal"	endif//	insert appropriate row(s) in table	StimHsize= dimsize(StimHistory,0)	if (StimHsize<=wavenum)		if (StimHsize==wavenum)			InsertPoints wavenum,1, StimHistory		else			InsertPoints StimHsize,(1+wavenum-StimHsize), StimHistory		endif	endif// enter all the other data 	ControlInfo /W=ADCDACControl $theDacPopup	StimHistory[wavenum][0]=S_Value                   		//the stimulus wave	StimHistory[wavenum][1]=num2str(theMD)         	//the wave multiplier	StimHistory[wavenum][2]=num2str(HoldV)     		//the holding potential	StimHistory[wavenum][3]=num2str(theDG)          	//gain on stimulator	StimHistory[wavenum][6]=num2str(pn)             	//pN	StimHistory[wavenum][7]=wave_comments            		//comments	StimHistory[wavenum][8]=time()                    		//approx. time of data acqisition	StimHistory[wavenum][9]=num2str(TempV)		//Temperature	StimHistory[wavenum][10]=num2str(rseal)		//SR	if (cmpstr(S_value,"StepPulse_DAC")==0)			//if the stim is a "step pulse"...		StimHistory[wavenum][4]=num2str(dpamp)     		 //the current step		StimHistory[wavenum][5]=num2str(dpdur)     		 //step duration	else		StimHistory[wavenum][4]=""     		 //don't put anything		StimHistory[wavenum][5]=""     		 //don't put anything	endif	SetDataFolder savDFEnd//______________________DataPro Data Acquisition PROCEDURES__________________________//Function MakeITCseq()	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol//	first determine the appropriate ad and da sequence strings	Silent 1	String shortdaseq, shortadseq	Variable i	NVAR nDACInUse, nADCInUse, seqlength=seqlength	SVAR daseq=daseq, adseq=adseq	WAVE dacon=dacon, ttlon=ttlon, adcon=adcon	nDACInUse=0	nADCInUse=0	daseq=""	adseq=""	i=0	do		if (dacon[i]>0)			daseq+=num2str(i)			nDACInUse+=1		endif		i+=1	while(i<4)	i=0	do		if (ttlon[i]>0)			daseq+="D"			nDACInUse+=1			break		endif		i+=1	while(i<4)	i=0	do		if (adcon[i]>0)			adseq+=num2str(i)			nADCInUse+=1		endif		i+=1	while(i<8)	seqlength=LCM(nDACInUse, nADCInUse)	//	calculate the length of the AD and DA sequence strings (must be the same)	if (nDACInUse!=nADCInUse)		shortdaseq=daseq; shortadseq=adseq		daseq=""; adseq=""		i=0		do			daseq+=shortdaseq			i+=1		while(i<seqlength/nDACInUse)		i=0		do			adseq+=shortadseq			i+=1		while(i<seqlength/nADCInUse)	endif	SetDataFolder savDFEndFunction SampleData()	// The heart of the data acquisition.  On exit, the acquired data is in the wave	// root:DP_ADCDACcontrol:FIFOin .	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	Variable sintpts	String doit	NVAR itc=itc, usPerDigitizerClockTick	SVAR daseq=daseq, adseq=adseq	WAVE StepPulse_DAC=StepPulse_DAC	if (itc<18)												// for the itc16		if (itc<1)			WAVE FIFOin=FIFOin			FIFOin=sin(0.05*x)+gnoise(0.1)+StepPulse_DAC+5		else			Execute "ITC16StimClear 0"			Execute "ITC16Seq daseq, adseq"			sintpts=deltax(FIFOout)*1000/usPerDigitizerClockTick			sprintf doit, "ITC16StimAndSample FIFOout, FIFOin, %d, 14", sintpts			Execute doit			Execute "ITC16StopAcq"		endif	else														// for the itc18		// might need to change acqflags to 14 to make this work		//Execute "ITC18StimClear 0"  // ALT, 2012/05/23		Execute "ITC18Seq daseq, adseq"		sintpts=deltax(FIFOout)*1000/usPerDigitizerClockTick		Execute "ITC18Stim FIFOout"		sprintf doit, "ITC18StartAcq %d,2,0", sintpts		Execute doit		Execute "ITC18Samp FIFOin"		Execute "ITC18StopAcq"	endif	SetDataFolder savDFEnd//___________________________DataPro CLAMP MODE___________________________//Function ToggleClampButtonProc(ctrlName) : ButtonControl	String ctrlName	print "switch all clamp modes together - not yet implemented"	Variable i=0//	do//		SwitchClampMode(i,x)//		i+=1//	while(i<8)EndFunction HandleADCChannelModePopupMenu(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	Variable iChannel		iChannel=str2num(ctrlName[strlen(ctrlName)-1])	SwitchADCChannelMode(iChannel,popNum)EndFunction SwitchADCChannelMode(iChannel,mode)	// Switches the indicated ADC channel to the given mode.  Currently, the mode can be 1 (==current)	// or 2 (==voltage)	Variable iChannel, mode		String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		WAVE adcType	WAVE adcgain, adcgain_voltage, adcgain_current	adcType[iChannel]=mode	if (mode==1)		adcgain[iChannel]=adcgain_current[iChannel]	else		adcgain[iChannel]=adcgain_voltage[iChannel]	endif	SyncADCGainSetVariableToModel(iChannel)	SetDataFolder savDFEndFunction HandleDACChannelModePopupMenu(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	Variable iChannel	iChannel=str2num(ctrlName[strlen(ctrlName)-1])	SwitchDACChannelMode(iChannel,popNum)EndFunction SwitchDACChannelMode(iChannel,mode)	// Switches the indicated DAC channel to the given mode.  Currently, the mode can be 1 (==current)	// or 2 (==voltage)	Variable iChannel, mode	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacType	WAVE dacgain,dacgain_voltage, dacgain_current	dacType[iChannel]=mode	if (mode==1)		dacgain[iChannel]=dacgain_current[iChannel]	else		dacgain[iChannel]=dacgain_voltage[iChannel]	endif	SyncDACGainSetVariableToModel(iChannel)	SetDataFolder savDFEnd//______________________DataPro ADC AND DAC CONTROL____________________////Function SetDACGain(iDACChannel)//	Variable iDACChannel//	String savDF=GetDataFolder(1)//	SetDataFolder root:DP_ADCDACcontrol//	WAVE dacgain//	NVAR pointsPerVoltDAC//	NVAR dacgain0=dacgain0, dacgain1=dacgain1, dacgain2=dacgain2, dacgain3=dacgain3 //	dacgain[0]=dacgain0//	dacgain[1]=dacgain1//	dacgain[2]=dacgain2//	dacgain[3]=dacgain3//	Variable usedacgain=dacgain[iDACChannel]//	Variable outgain=pointsPerVoltDAC/usedacgain	// has units points/unitsVoltage (VC) or points/unitsCurrent (CC)//	SetDataFolder savDF//	return outgain//EndFunction SyncDACGainWaveToVars()	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacgain	NVAR dacgain0=dacgain0, dacgain1=dacgain1, dacgain2=dacgain2, dacgain3=dacgain3 	dacgain[0]=dacgain0	dacgain[1]=dacgain1	dacgain[2]=dacgain2	dacgain[3]=dacgain3	SetDataFolder savDFEndFunction ComputeOutputGain(iDACChannel)	// Calculates the output gain (in points per native unit) based on the gain for the given 	// channel and pointsPerVoltDAC.	Variable iDACChannel	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacgain	// (native units)/V	NVAR pointsPerVoltDAC	// points/V	Variable outgain=pointsPerVoltDAC/dacgain[iDACChannel]	// points/(native unit)	SetDataFolder savDF	return outgainEnd//Function SetADCGain(iADCChannel)//	// Syncs the adcgain wave to the adcgain<i> variables.//	// Also sets ingain based on the gain for the given channel and pointsPerVoltADC.//	Variable iADCChannel//	SyncADCGainWaveToVars()//	return ComputeInputGain(iADCChannel)//End//Function SyncADCGainWaveToVars()//	// Syncs the adcgain wave to the adcgain<i> variables.//	Variable iADCChannel//	String savDF=GetDataFolder(1)//	SetDataFolder root:DP_ADCDACcontrol//	//	// these are the "inputs" to this procedure//	NVAR adcgain0, adcgain1, adcgain2, adcgain3//	NVAR adcgain4, adcgain5, adcgain6, adcgain7//	// these are the outputs of this procedure//	WAVE adcgain//	//	// do what's described above//	adcgain[0]=adcgain0//	adcgain[1]=adcgain1//	adcgain[2]=adcgain2//	adcgain[3]=adcgain3//	adcgain[4]=adcgain4//	adcgain[5]=adcgain5//	adcgain[6]=adcgain6//	adcgain[7]=adcgain7//	//	// Restore the DF//	SetDataFolder savDF//EndFunction ComputeInputGain(iADCChannel)	// Calculates the input gain (in native units per point) based on the gain for the given 	// channel and pointsPerVoltADC.	Variable iADCChannel		// Set the DF	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		// these are the "inputs" to this procedure	NVAR pointsPerVoltADC		// points/V	Wave adcgain	// V/(native unit)		// do what's described above	Variable ingain=1/(adcgain[iADCChannel]*pointsPerVoltADC)		// (native units)/point	// Restore the DF		SetDataFolder savDF	// Exit	return ingainEndFunction HandleADCGainSetVariable(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE adcType	WAVE adcgain	WAVE adcgain_current, adcgain_voltage		Variable i=str2num(ctrlName[7])  // ADC channel index	if (adcType[i]==1)		adcgain_current[i]=varNum	else		adcgain_voltage[i]=varNum			endif	adcgain[i]=varNum		SetDataFolder savDFEndFunction SyncADCGainSetVariableToModel(i)	Variable i 	// ADC channel index	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE adcgain	String setVariableName=sprintf1d("adcGain%dSetVariable",i)	SetVariable $setVariableName value=_NUM:adcgain[i]	SetDataFolder savDF	EndFunction HandleDACGainSetVariable(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		WAVE dacType	WAVE dacgain	WAVE dacgain_current, dacgain_voltage	Variable i=str2num(ctrlName[7])  // DAC channel index	if (dacType[i]==1)		dacgain_current[i]=varNum	else		dacgain_voltage[i]=varNum			endif	dacgain[i]=varNum			SetDataFolder savDFEndFunction SyncDACGainSetVariableToModel(i)	Variable i 	// DAC channel index	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacgain	String setVariableName=sprintf1d("dacGain%dSetVariable",i)	SetVariable $setVariableName value=_NUM:dacgain[i]	SetDataFolder savDF	EndFunction ADC_DACButtonProc(ctrlName) : ButtonControl	String ctrlName	RaiseOrCreatePanel("ADCDACControl")EndFunction ADCDACcheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable box	box=str2num(ctrlName[6])	String wavetochange	sprintf wavetochange, "%son", ctrlName[0,2]	Wave adcdacttlon = $wavetochange	adcdacttlon[box]=checked	SetDataFolder savDFEndFunction SaveControlButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "SaveControls()"EndProc SaveControls()	Variable ControlFileVar	String pop	Variable i	Open ControlFileVar  as "ADCoutputFile"	i=0	do		fprintf ControlFileVar, "%d\r%g\r%s\r", adcon[i], adcgain[i], adcname[i]		i+=1	while(i<8)	i=0	do		fprintf ControlFileVar, "%d\r%g\r", dacon[i], dacgain[i]		sprintf pop "dacpopup_%d", i		ControlInfo /W=ADCDACControl $pop		fprintf ControlFileVar, "%s\r", S_value		i+=1	while(i<4)	i=0	do		fprintf ControlFileVar, "%d\r", ttlon[i]		sprintf pop "ttlpopup_%d", i		ControlInfo /W=ADCDACControl $pop		fprintf ControlFileVar, "%s\r", S_value		i+=1	while(i<4)	Close ControlFileVarEndFunction ReadControlButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "ReadControls()"EndProc ReadControls()	Variable ControlFileVar	String instring, pop, box, list, thestr, msg	Variable i, j, x	Open /R ControlFileVar	i=0	do		FReadLine ControlFileVar, instring		adcon[i]=str2num(instring)		sprintf box, "adcon_%d", i		CheckBox $box win=ADCDACControl, value=adcon[i]		FReadLine ControlFileVar, instring		adcgain[i]=str2num(instring)		FReadLine ControlFileVar, instring		x=strlen(instring)-2		adcname[i]=instring[0,x]		i+=1	while(i<8)	i=0	do		FReadLine ControlFileVar, instring		dacon[i]=str2num(instring)		sprintf box, "dacon_%d", i		CheckBox $box win=ADCDACControl, value=dacon[i]		FReadLine ControlFileVar, instring		dacgain[i]=str2num(instring)		FReadLine ControlFileVar, instring		instring=instring[0,strlen(instring)-2]		list="_none_;"+Wavelist("*_DAC",";","")		j=1		do			thestr=GetStrFromList(list,j-1,";")			if (cmpstr(thestr,instring)==0)				break			endif			if (strlen(thestr)==0)				sprintf msg, "DAC wave %s not found for DAC%d.", instring, i				Abort msg			endif			j+=1		while(1)		sprintf pop "dacpopup_%d", i		PopupMenu $pop mode=j		i+=1	while(i<4)	i=0	do		FReadLine ControlFileVar, instring		ttlon[i]=str2num(instring)		sprintf box, "ttlon_%d", i		CheckBox $box win=ADCDACControl, value=ttlon[i]		FReadLine ControlFileVar, instring		instring=instring[0,strlen(instring)-2]		list="_none_;"+Wavelist("*_TTL",";","")		j=1		do			thestr=GetStrFromList(list,j-1,";")			if (cmpstr(thestr,instring)==0)				break			endif			if (strlen(thestr)==0)				sprintf msg, "TTL wave %s not found for TTL%d.", instring, i				Abort msg			endif			j+=1		while(1)		sprintf pop "ttlpopup_%d", i		PopupMenu $pop mode=j		i+=1	while(i<4)	Wave2Vars("dacgain","dacgain",4)	Wave2Vars("adcgain","adcgain",8)	Wave2Vars("adcname","adcname",8)	Close ControlFileVarEnd//__________________________DataPro DAC PULSE BUILER___________________________//Function DACBuilderButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("DACPulses")<1)		Execute "DACPulses()"	else		DoWindow /F DACPulses		endifEndFunction ReadwaveButtonProc(ctrlName) : ButtonControl	String ctrlName	LoadWaveEndFunction SaveDACButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "SaveDAC()"EndFunction SaveDAC(namestr)	String namestr	Prompt namestr, "Enter a wavename with an extension _DAC or _TTL:"	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String filestr	filestr=namestr+".bwav"	Duplicate /O NewDAC $namestr	Save/C $namestr as filestr	SetDataFolder savDFEndFunction FiveSegButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("FiveSegBuilder")<1)		Execute "FiveSegBuilder()"		Execute "StepVarChange()"	else		DoWindow /F FiveSegBuilder	endifEndFunction StepVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "StepVarChange()"EndFunction FromFileCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	NVAR ffseg=ffseg	String doit	if (checked>0)		ffseg=str2num(ctrlName[3])//		print ffseg		Execute "FFWaveInput()"	else		Execute "StepVarChange()"	endif	SetDataFolder savDFEndProc FFWaveInput(waveinput)	String waveinput	Prompt waveinput, "Select wave to insert:", popup Wavelist("*_DAC",";","")+Wavelist("*_TTL",";","")	String waveoutput	sprintf waveoutput, "ffwave%d", ffseg	if (deltax($waveinput)!=deltax(Step5DAC))		CheckBox ff_2 win=FiveSegBuilder, value=0		Abort "Sample Interval Mismatch"	else		Duplicate /O $waveinput $waveoutput		StepVarChange()	endifEndProc StepVarChange()	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable i, first, last, totaldur, firstp, lastp	String ffstr, notestr	Vars2Wave("stepdur","duration",5)	Vars2Wave("stepamp","amplitude",5)	PauseUpdate	totaldur=0	i=0	do		sprintf ffstr, "ff_%d", i		ControlInfo $ffstr		if (V_value>0)			sprintf ffstr, "ffwave%d", i			duration[i]=numpnts($ffstr)*deltax($ffstr)			//print duration[i]			Wave2Vars("duration","stepdur",5)		endif		totaldur+=duration[i]		i+=1	while(i<5)	print totaldur, sintpb	Redimension /N=(totaldur/sintpb) Step5DAC	Setscale /P x, 0, sintpb, "ms", Step5DAC	Note /K Step5DAC	ReplaceStringByKeyInWaveNote(Step5DAC,"WAVETYPE","step5dac")	ReplaceStringByKeyInWaveNote(Step5DAC,"TIME",time())	ReplaceStringByKeyInWaveNote(Step5DAC,"STEP",num2str(amplitude[1]))	first=0	i=0	do		last=first+duration[i]		sprintf ffstr, "ff_%d", i		ControlInfo $ffstr		if (V_value<1)			Step5DAC(first,last)=amplitude[i]		else			sprintf ffstr, "ffwave%d", i			amplitude[i]=0			firstp=x2pnt(Step5DAC, first)			lastp=x2pnt(Step5DAC, last)			Step5DAC[firstp,lastp]=$ffstr[p-firstp]			Wave2Vars("amplitude","stepamp",5)		endif		first=last+sintpb		sprintf notestr, "AMP%d", i		ReplaceStringByKeyInWaveNote(Step5DAC,notestr,num2str(amplitude[i]))		sprintf notestr, "DUR%d", i		ReplaceStringByKeyInWaveNote(Step5DAC,notestr,num2str(duration[i]))		i+=1	while(i<5)	ResumeUpdate	Duplicate /O Step5DAC NewDAC	SetDataFolder savDFEndFunction EditFiveSegWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String showstr	sprintf showstr, "ShowFiveSegWave(\"%s\")", popStr	Execute showstr	SetDataFolder savDFEndProc ShowFiveSegWave(popstr)	String popstr	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		stepdur0=10; stepdur1=10; stepdur2=10; stepdur3=10; stepdur4=10		stepamp1=10; stepamp3=10; sintpb=0.01		StepVarChange()	else		keyval=StringByKeyInWaveNote($popstr,"WAVETYPE")		if (cmpstr(keyval,"step5dac")==0)			sintpb=deltax($popstr)			do				sprintf keyword, "DUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				sprintf keyword, "AMP%d", i				amplitude[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<5)			Wave2Vars("duration", "stepdur", 5)			Wave2Vars("amplitude", "stepamp", 5)			StepVarChange()		else			Abort("This is not a five segment wave; choose another")		endif	endif	SetDataFolder savDFEndFunction TrainButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("TrainBuilder")<1)		Execute "TrainVarChange()"		Execute "TrainBuilder()"	else		DoWindow /F TrainBuilder	endifEndFunction TrainVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "TrainVarChange()"EndProc TrainVarChange()	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable i, j, first, last, totaldur	String notestr	traindur1=(trainnum/trainfreq)*1000	Vars2Wave("traindur","duration",3)	PauseUpdate	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<3)	Redimension /N=(totaldur/sintpb) TrainDAC	Setscale /P x, 0, sintpb, "ms", TrainDAC	Note /K TrainDAC	ReplaceStringByKeyInWaveNote(TrainDAC,"WAVETYPE","traindac")	ReplaceStringByKeyInWaveNote(TrainDAC,"TIME",time())	TrainDAC=trainbase	first=0	i=0	do		if (i==1)			j=0			do				last=first+traindur				TrainDAC(first,last)=trainbase+trainamp				first+=1000/trainfreq+sintpb				j+=1			while(j<trainnum)		else			last=first+duration[i]			TrainDAC(first,last)=trainbase		endif		first=last+sintpb		sprintf notestr, "TRAINDUR%d", i		ReplaceStringByKeyInWaveNote(TrainDAC,notestr, num2str(duration[i]))		i+=1	while(i<3)	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINNUM", num2str(trainnum))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINFREQ", num2str(trainfreq))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINBASE", num2str(trainbase))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINAMP", num2str(trainamp))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINUPDUR", num2str(traindur))	ResumeUpdate	Duplicate /O TrainDAC NewDAC	SetDataFolder savDFEndFunction EditTrainWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowTrainWave(\"%s\")", popStr	Execute showstrEndProc ShowTrainWave(popstr)	String popstr	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		traindur0=10; traindur1=10; traindur2=10; trainnum=10		trainfreq=10; trainamp=10; trainbase=0; traindur=2; sintpb=0.01		TrainVarChange()	else		keyval=StringByKeyInWaveNote($popstr, "WAVETYPE")		if (cmpstr(keyval,"traindac")==0)			sintpb=deltax($popstr)			do				sprintf keyword, "TRAINDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "traindur", 3)			sprintf keyword, "TRAINNUM"			trainnum=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINFREQ"			trainfreq=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINAMP"			trainamp=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINBASE"			trainbase=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINUPDUR"			traindur=NumberByKeyInWaveNote($popstr,keyword)			TrainVarChange()		else			Abort("This is not a train wave; choose another")		endif	endif	SetDataFolder savDFEndFunction RampButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("RampBuilder")<1)		Execute "RampVarChange()"		Execute "RampBuilder()"	else		DoWindow /F RampBuilder	endifEndFunction RampVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "RampVarChange()"EndProc RampVarChange()	String savDF= GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol:	Variable i, j, first, last, totaldur, slope	String notestr	Vars2Wave("rampdur","duration",3)	Vars2Wave("rampamp","amplitude",3)//	amplitude[0]=amplitude[1]//	rampamp0=rampamp1	PauseUpdate	totaldur=0	i=1	do		totaldur+=duration[i]		i+=1	while(i<5)	Redimension /N=(totaldur/sintpb) RampDAC	Setscale /P x, 0, sintpb, "ms", RampDAC	Note /K RampDAC	ReplaceStringByKeyInWaveNote(RampDAC,"WAVETYPE","rampdac")	ReplaceStringByKeyInWaveNote(RampDAC,"TIME",time())	slope=(rampamp3-rampamp1)/rampdur2	first=0	i=1	do		if (i==2)			last=first+rampdur2			RampDAC(first,last)=rampamp1+slope*(x-rampdur1)		else			last=first+duration[i]			RampDAC(first,last)=amplitude[i]		endif		first=last+sintpb		sprintf notestr, "RAMPDUR%d", i		ReplaceStringByKeyInWaveNote(RampDAC,notestr, num2str(duration[i]))		sprintf notestr, "RAMPAMP%d", i		ReplaceStringByKeyInWaveNote(RampDAC,notestr, num2str(amplitude[i]))		i+=1	while(i<5)	ResumeUpdate	Duplicate /O RampDAC NewDAC	SetDataFolder savDFEndFunction EditRampWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowRampWave(\"%s\")", popStr	Execute showstrEndProc ShowRampWave(popstr)	String popstr	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		rampdur0=10; rampdur1=50; rampdur2=10		rampamp1=-10; rampamp2=10; sintpb=0.01		RampVarChange()	else		keyval=StringByKeyInWaveNote("WAVETYPE",$popstr)		if (cmpstr(keyval,"rampdac")==0)			sintpb=deltax($popstr)			do				sprintf keyword, "RAMPDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				sprintf keyword, "RAMPAMP%d", i				amplitude[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "rampdur", 3)			Wave2Vars("amplitude", "rampamp", 3)			RampVarChange()		else			Abort("This is not a ramp wave; choose another")		endif	endifEndFunction PSCButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("PSCBuilder")<1)		Execute "PSCVarChange()"		Execute "PSCBuilder()"	else		DoWindow /F PSCBuilder	endifEndFunction PSCVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "PSCVarChange()"EndProc PSCVarChange()	Variable i, j, first, last, totaldur, max, scale, rise, decay1, decay2, err	String notestr, savDF	savDF=GetDataFolder(1)	SetDataFolder "root:DP_ADCDACcontrol"	Vars2Wave("pscdur","duration",3)	PauseUpdate	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<3)	Redimension /N=(totaldur/sintpb) PSCDAC	Setscale /P x, 0, sintpb, "ms", PSCDAC	Note /K PSCDAC	ReplaceStringByKeyInWaveNote(PSCDAC,"WAVETYPE","pscdac")	ReplaceStringByKeyInWaveNote(PSCDAC,"TIME",time())	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCAMP",num2str(pscamp))	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCTAUR",num2str(psctaur))	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCTAUD1",num2str(psctaud1))	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCTAUD2",num2str(psctaud2))	ReplaceStringByKeyInWaveNote(PSCDAC,"WTTD2",num2str(wttd2))	scale=1.37		// correct value is unique for each psc wave; adjusted in loop below	first=0	i=0	do		if (i==1)			last=first+pscdur1			PSCDAC(first,last)=pscamp*scale*-exp((pscdur0-x)/psctaur)			PSCDAC(first,last)+=(1-wttd2)*pscamp*scale*exp((pscdur0-x)/psctaud1)			PSCDAC(first,last)+=wttd2*pscamp*scale*exp((pscdur0-x)/psctaud2)			do				Wavestats /Q/R=(first,last) PSCDAC				if (abs(V_min)<V_max)					err=(V_max-pscamp)/pscamp				else					err=(V_min-pscamp)/pscamp				endif				PSCDAC=PSCDAC*(1-err)			while(abs(err)>0.001)		else			last=first+duration[i]			PSCDAC(first,last)=0		endif		first=last+sintpb		sprintf notestr, "PSCDUR%d", i		ReplaceStringByKeyInWaveNote(PSCDAC,notestr,num2str(duration[i]))		i+=1	while(i<3)	ResumeUpdate	Duplicate /O PSCDAC NewDAC	SetDataFolder savDFEndFunction EditPSCWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowPSCWave(\"%s\")", popStr	Execute showstrEndProc ShowPSCWave(popstr)	String popstr	String keyword, keyval, savDF	Variable i	savDF=GetDataFolder(1)	SetDataFolder "DP_ADCDACcontrol"	if (cmpstr(popstr,"_New_")==0)		pscdur0=10; pscdur1=50; pscdur2=10; pscamp=10		psctaur=0.2; psctaud1=2; psctaud2=10; wttd2=0.5; sintpb=0.01		PSCVarChange()	else		keyval=StringByKeyInWaveNote("WAVETYPE", $popstr)		if (cmpstr(keyval,"pscdac")==0)			pscamp=NumberByKeyInWaveNote($popstr,"PSCAMP")			psctaur=NumberByKeyInWaveNote($popstr,"PSCTAUR")			psctaud1=NumberByKeyInWaveNote($popstr,"PSCTAUD1")			psctaud2=NumberByKeyInWaveNote($popstr,"PSCTAUD2")			wttd2=NumberByKeyInWaveNote($popstr,"WTTD2")			sintpb=deltax($popstr)			do				sprintf keyword, "PSCDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "pscdur", 3)			PSCVarChange()		else			Abort("This is not a PSC wave; choose another")		endif	endif	SetDataFolder savDFEndFunction SineButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("SineBuilder")<1)		Execute "SineVarChange()"		Execute "SineBuilder()"	else		DoWindow /F SineBuilder	endifEndFunction SineVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "SineVarChange()"EndProc SineVarChange()	Variable i, j, first, last, totaldur, max, scale, rise, decay1, decay2, err	String notestr	String savDF	savDF=GetDataFolder(1)	SetDataFolder "root:DP_ADCDACcontrol"	Vars2Wave("sinedur","duration",3)	PauseUpdate	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<3)	Redimension /N=(totaldur/sintpb) SineDAC	Setscale /P x, 0, sintpb, "ms", SineDAC	Note /K SineDAC	ReplaceStringByKeyInWaveNote(SineDAC,"WAVETYPE","sinedac")	ReplaceStringByKeyInWaveNote(SineDAC,"TIME",time())	ReplaceStringByKeyInWaveNote(SineDAC,"SINEAMP",num2str(sineamp))	ReplaceStringByKeyInWaveNote(SineDAC,"SINEFREQ",num2str(sinefreq))	scale=1.37		// correct value is unique for each psc wave; there is a way to calculate this, but I forget	first=0	i=0	do		last=first+duration[i]		if (i==1)			SineDAC(first,last)=sineamp*sin(sinefreq*2*PI*(x-sinedur0)/1000)		else			SineDAC(first,last)=0		endif		first=last+sintpb		sprintf notestr, "SINEDUR%d", i		ReplaceStringByKeyInWaveNote(SineDAC,notestr,num2str(duration[i]))		i+=1	while(i<3)	ResumeUpdate	Duplicate /O SineDAC NewDAC	SetDataFolder savDFEndFunction EditSineWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowSineWave(\"%s\")", popStr	Execute showstrEndProc ShowSineWave(popstr)	String popstr	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		sinedur0=10; sinedur1=50; sinedur2=10; sineamp=10; sinefreq=100; sintpb=0.01		SineVarChange()	else		keyval=StringByKeyInWaveNote("WAVETYPE",$popstr)		if (cmpstr(keyval,"sinedac")==0)			sineamp=NumberByKeyInWaveNote($popstr,"SINEAMP")			sinefreq=NumberByKeyInWaveNote($popstr,"SINEFREQ")			sintpb=deltax($popstr)			do				sprintf keyword, "SINEDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "sinedur", 3)			SineVarChange()		else			Abort("This is not a sine wave; choose another")		endif	endifEndFunction ViewDACButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "DACViewer()"EndFunction handleViewDacPopupSelection(ctrlName,itemNum,itemStr) : PopupMenuControl	String ctrlName	Variable itemNum	String itemStr	// Save current data folder, set to one we want.	String savedFolderName= GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol:		// Remove the current trace, put in the new one.	RemoveFromGraph /Z $"#0"	if ( cmpstr(itemStr,"(none)")!=0 )		AppendToGraph $itemStr		ModifyGraph grid(left)=1  // put the grid back	endif		// Restore the original data folder.	SetDataFolder savedFolderNameEnd//______________________Other DataPro PROCEDURES__________________________//// copy a list of variable names (with common base) into a waveFunction Wave2Vars(wbase,vbase,n)	String wbase, vbase	Variable n	Wave thewave=$wbase	String var, thevalue	do		sprintf var, "%s%d", vbase, n-1		NVAR thestring=$var		thestring=thewave[n-1]	//	print var, thestring, thewave[n-1]		n-=1	while(n>0)End// copy a list of variable names (with common base) into a waveFunction Wave2StringVars(wbase,vbase,n)	String wbase, vbase	Variable n	Wave /T thewave=$wbase	String var, thevalue	do		sprintf var, "%s%d", vbase, n-1		SVAR thestring=$var		thestring=thewave[n-1]	//	print var, thestring, thewave[n-1]		n-=1	while(n>0)End// copy a wave into a list of variable names (with common base)Function Vars2Wave(vbase,wbase,n)	String vbase, wbase	Variable n	String var	do		sprintf var, "%s%d", vbase, n-1		Wave varwave=$wbase		NVAR value=$var		varwave[n-1]=value		n-=1	while(n>0)EndFunction SetBaseNameProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Vars2Wave("adcname","adcname",8)End//Function ResetAxesProc(ctrlName,varNum,varStr,varName) : SetVariableControl//	String ctrlName//	Variable varNum//	String varStr//	String varName//	RescaleTopAxes()//EndFunction CursorsCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	SVAR thiswave=thiswave	PlaceCursors(thiswave)End//_______________________Other DataPro FUNCTIONS___________________________//// returns 1 if option-cmd-dot pressedFunction HaltProcedures()	String s	s = KeyboardState("")	if (cmpstr(s[9], " ")==0)		// is spacebar pressed?		return 1	endif	return 0End// Compute Greatest Common Divisor// this is now included with Igor 5//Function GCD(a,b)//	Variable	a,b//	a=round(abs(a))		//+ive integers//	b=round(abs(b))//	if(a==0 %& b==0 )//		Abort	"Undefined when both numbers are zero"//	EndIf//	Variable rest//	If(b>a)		// swap so a > b//		rest=a//		a=b//		b=rest//	EndIf//	do//		rest=mod(a,b)//		a=b//		b=rest//	while(b!=0)//	Return a//End// Compute Least Common MultipleFunction LCM(a,b)	Variable	a,b	Return((a*b)/GCD(a,b))End// Remove a list of waves from the top graphFunction RemoveWaves(list,graph)	String list, graph	String theWave	Variable index=0	DoWindow /F $graph	do		theWave=GetStrFromList(list,index,";")		if (strlen(theWave)==0)			break		endif		RemoveFromGraph $theWave		index+=1	while(1)	//  loop until break aboveEnd