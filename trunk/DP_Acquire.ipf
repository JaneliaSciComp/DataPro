//	DataPro//	DAC/ADC macros for use with Igor Pro and the ITC-16 or ITC-18//	Nelson Spruston//	Northwestern University//	project began 10/27/1998//	last updated 6/12/2002#pragma rtGlobals=1		// Use modern global access method.//---------------------- DataPro Acquire STARTUP ----------------------//Function MakeADCDACWaves()	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	Variable xpnts=140//	make the dac and adc waves	Make/O/N=(xpnts) DACwave	Setscale x, 0, 0, "ms", DACwave	SetScale d 0, 0, "points", DACwave//	make FIFOin and FIFOout	Duplicate DACwave FIFOout	Duplicate DACwave FIFOin	//	now make ADCWave	Duplicate /O DACWave ADCwave	ADCWave=0//	SetScale d 0,0,unitsCurrent, ADCwave//	if (clamp_mode>0)//		SetScale d 0,0,unitsVoltage, ADCwave//	endif	SetScale d 0,0,"", ADCwave  // does this do anything?//	now make the test pulse DAC and ADC waves	Make /O/N=(xpnts) TestPulse_DAC	SetScale d 0,0,"points", TestPulse_DAC	Setscale x, 0, 0, "ms", TestPulse_DAC	Duplicate /O TestPulse_DAC TestPulse_ADC//	now make the data pulse DAC and ADC waves	Make /O/N=(xpnts) StepPulse_DAC	SetScale d 0,0,"points", StepPulse_DAC	Setscale x, 0, 0, "ms", StepPulse_DAC	Duplicate /O StepPulse_DAC StepPulse_ADC	Duplicate /O StepPulse_DAC SynPulse_TTL//	make waves for pulse builder	Make /O/N=1000 Step5DAC, TrainDAC, RampDAC, PSCDAC, SineDAC, NewDAC	Make /O/N=5 amplitude, duration	Variable /G stepdur0, stepdur1, stepdur2, stepdur3, stepdur4	Variable /G stepamp0, stepamp1, stepamp2, stepamp3, stepamp4, sintpb	stepdur0=10; stepdur1=10; stepdur2=10; stepdur3=10; stepdur4=10	stepamp1=10; stepamp3=10; sintpb=0.01	Variable /G traindur0, traindur1, traindur2, trainnum, trainfreq, trainamp, trainbase, traindur	traindur0=10; traindur1=10; traindur2=10; trainnum=10	trainfreq=10; trainamp=10; trainbase=0; traindur=2	Variable /G rampdur1, rampdur2, rampdur3, rampdur4, rampamp1, rampamp2, rampamp3, rampamp4	rampdur1=10; rampdur2=50; rampdur3=10; rampdur4=10; rampamp1=-10; rampamp2=0; rampamp3=10; rampamp4=0	Variable /G pscdur0, pscdur1, pscdur2, pscamp, psctaur, psctaud1, psctaud2, wttd2	pscdur0=10; pscdur1=50; pscdur2=10; pscamp=10; psctaur=0.2; psctaud1=2; psctaud2=10; wttd2=0.5	Variable /G sinedur0, sinedur1, sinedur2, sineamp, sinefreq	sinedur0=10; sinedur1=50; sinedur2=10; sineamp=10; sinefreq=100//	for PN subtraction	Variable /G pn	pn=-4//	check for error condition	Variable /G error//	make average wave for imaging	//NewDataFolder /O/S root:DP_Imaging	//Make /N=(imageavgn) dff_avg//	return to default folder	SetDataFolder savDFEndFunction SetupGlobals()	//	Acquisition globals	//	USERS SHOULD NOT EDIT ANYTHING HERE	//	EDIT ONLY IN THE MyVariables FILE	Silent 1	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol		// Current and voltage units (set in the user function)	String /G unitsCurrent, unitsVoltage	// ITC model	Variable /G itc=18		// Should we run the user's custom automatic analysis function after each sweep?	Variable /G autoAnalyzeChecked=0		// true iff AutoAnalyze checkbox is checked	// Variables controlling the trials and sweeps	Variable /G iSweep=1		// index of the current/next sweep to be acquired	Variable /G nSweepsPerTrial=1	Variable /G sweep_interval=10		// seconds	// Variables related to the test pulse	Variable /G tpamp	// test pulse amplitude, units determined by channel type	Variable /G tpdur		// test pulse duration, ms	Variable /G tpgate 	// boolean, true iff the gate should be used	Variable /G tpgateamp	Variable /G sinttp=0.02		// sample interval for the test pulse, ms	Variable /G tpscale=1		// what is this?	Variable /G testadc=0		// index of the ADC channel to be used for the test pulse	Variable /G testdac=0		// index of the DAC channel to be used for the test pulse		Variable /G baseline_sub=1	// boolean, whether or not to do baseline subtraction	Variable /G RSeal			// the computed seal resistance, GOhm	// global variables for DAC waves (?)	//Variable /G ffseg=1	//Variable /G sintdisp=0.01	// These control the StepPulse_DAC wave	Variable /G spamp=1		// amplitude in units given by channel type	Variable /G spdur=1000	// duration in ms	//Variable /G splow, sphigh, spshort, splong	Variable /G sintsp=0.05	// sample interval for the step pulse, ms	// Parameters of SynPulse_DAC	Variable /G syntime=50		Variable /G syndur=0.1	// seconds (?)	// For comments	//String /G wave_comments	// initial type of ADC, DAC channels (currently can be 1==current or 2==voltage)	Make /O /N=8 adcType	adcType={2,2,2,2,2,2,2,2}		// all voltage channels	Make /O /N=4 dacType	dacType={1,1,1,1}		// all current channels 	// Make waves for adc and dac gains	Make /O/N=8 adcgain, adcgain_current, adcgain_voltage	Make /O/N=4 dacgain, dacgain_current, dacgain_voltage	dacgain_current=dacgain; dacgain_voltage=dacgain	adcgain_current=adcgain; adcgain_voltage=adcgain	// Multipliers for the DAC channels	//Variable /G multdac, multdac0, multdac1, multdac2, multdac3, multdacD	Make /O /N=4 dacMultiplier	dacMultiplier={1,1,1,1}		// string variables for adc in wave names	Make /O/T/N=8 adcBaseName	adcBaseName={"ad0","ad1","ad2","ad3","ad4","ad5","ad6","ad7"}	// the sample interval	//Variable /G sint	//sint=0.05		// final sample interval, ms		// Make waves to read which adc/dac/ttl devices should be on	Make /O/N=8 adcon	adcon[0]=1		// turn on ADC 0 by default	Make /O/N=4 dacon	dacon[0]=1		// turn on DAC 0 by default	Make /O/N=4 ttlon	// all TTL outputs off by default		// now assign some other variables	//Variable /G pointsPerVoltADC=32768/10.24				// How many volts at the ADC correspond to a 1 bit change in the least significant bit	//Variable /G pointsPerVoltDAC=32768/10.24				// How many volts does the DAC output change in response to a 1 bit change in the least significant bit		// RETURN TO DEFAULT FOLDER	SetDataFolder savDFEndFunction SetupGlobalsPostUser()	// USERS SHOULD NOT EDIT THIS FUNCTION	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		NVAR itc	WAVE adcType,dacType	//NVAR dacgain0_current,dacgain1_current,dacgain2_current,dacgain3_current	//NVAR dacgain0_voltage,dacgain1_voltage,dacgain2_voltage,dacgain3_voltage	//NVAR adcgain0_current,adcgain1_current,adcgain2_current,adcgain3_current	//NVAR adcgain4_current,adcgain5_current,adcgain6_current,adcgain7_current	//NVAR adcgain0_voltage,adcgain1_voltage,adcgain2_voltage,adcgain3_voltage	//NVAR adcgain4_voltage,adcgain5_voltage,adcgain6_voltage,adcgain7_voltage	//NVAR adcgain0,adcgain1,adcgain2,adcgain3	//NVAR adcgain4,adcgain5,adcgain6,adcgain7	//NVAR dacgain0,dacgain1,dacgain2,dacgain3	WAVE adcgain, dacgain	WAVE dacgain_current, adcgain_current, dacgain_voltage, adcgain_voltage		Variable /G usPerDigitizerClockTick	if (itc<18)		usPerDigitizerClockTick=1	// 1 usec for itc16	else		usPerDigitizerClockTick=1.25	// 1.25 usec for itc18	endif		String commandLine	Variable i	for (i=0; i<8; i=i+1)		if (adcType[i]==1)			// current channel			adcgain[i]=adcgain_current[i]		else			// voltage channel			adcgain[i]=adcgain_voltage[i]		endif	endfor	for (i=0; i<4; i=i+1)		if (dacType[i]==1)			// current channel			dacgain[i]=dacgain_current[i]		else			// voltage channel			dacgain[i]=dacgain_voltage[i]		endif	endfor	//dacgain_current={dacgain0_current, dacgain1_current, dacgain2_current, dacgain3_current}	//adcgain_current={adcgain0_current, adcgain1_current, adcgain2_current, adcgain3_current, adcgain4_current, adcgain5_current, adcgain6_current, adcgain7_current}	//dacgain_voltage={dacgain0_voltage, dacgain1_voltage, dacgain2_voltage, dacgain3_voltage}	//adcgain_voltage={adcgain0_voltage, adcgain1_voltage, adcgain2_voltage, adcgain3_voltage, adcgain4_voltage, adcgain5_voltage, adcgain6_voltage, adcgain7_voltage}	SetDataFolder savDFEnd//_______________________DataPro TEST PULSE MACROS_________________________//Function BuildTestPulse()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	NVAR sinttp, tpgate, tpamp, tpdur	Variable numsegs, sintms, first, last, totaldur, xpnts, i	numsegs=3	Make /O/N=(numsegs) amplitude, duration	amplitude=0	duration=2	// user contolled variables	// amplitudes have units specified in unitsCurrent/unitsVoltage; 	// durations and sample interval have units of ms	sintms=sinttp					// sample interval (ms)	DoWindow /F TestPulsePanel	ControlInfo tpgate_check	if (V_value>0)		amplitude[1]=tpgate		// amplitude of second segment for gate mode	else		amplitude[1]=tpamp		// amplitude of second segment	endif	duration[0]=0.5*tpdur		// duration of first segment (ms)	duration[1]=tpdur			// duration of second segment (ms)	duration[2]=0.5*tpdur		// duration of third segment (ms)//	fixed and calculated variables	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<numsegs)	xpnts=totaldur/sintms	Make /O/N=(xpnts) TestPulse_DAC	Wave TestPulse_DAC=TestPulse_DAC	Setscale x, 0, totaldur, "ms", TestPulse_DAC	first=0	last=duration[0]/sintms	i=0	do		TestPulse_DAC[first,last]=amplitude[i]		first=last+1		last=first+duration[i+1]/sintms-1		i+=1	while(i<numsegs)	SetDataFolder savDFEndFunction StartTestPulse()//	called by Start button in Test Pulse Window only	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable  testtrigger, testtrigttl, miny, maxy	testtrigger=1; testtrigttl=2	if (wintype("TestPulseDisplay")<1)		TestPulseDisplay()	endif	DoWindow /F TestPulsePanel	SetTPvalues()	BuildTestPulse()	WAVE TestPulse_DAC	WAVE TestPulse_ADC	WAVE TestTrig_TTL	WAVE FIFOout	WAVE FIFOin	WAVE dacMultiplier	Duplicate /O TestPulse_DAC FIFOout, FIFOin, TestPulse_ADC, TestTrig_TTL	NVAR testdac	//outgain=SetDACGain(testdac)	Variable outgain=ComputeOutputGain(testdac)	NVAR testadc	//SyncADCGainWaveToVars()	Variable ingain=ComputeInputGain(testadc)	String daseq=num2str(testdac)	String adseq=num2str(testadc)	//outgain=SetDACGain(testdac)	NVAR sinttp	if (testtrigger>0)		daseq+="D"		adseq+=num2str(testadc)		TestTrig_TTL=0		TestTrig_TTL[1,11]=2^testtrigttl		Make /O/N=(numpnts(TestPulse_DAC)*2) FIFOout, FIFOin		Setscale /P x, 0, sinttp/2, "ms", FIFOout, FIFOin		// revise to reflect length of daseq // also this should happen also for no trigger //		FIFOout[0,;2]=TestPulse_DAC[p/2]*outgain*dacMultiplier[testdac]		FIFOout[1,;2]=TestTrig_TTL[p/2]	else		FIFOout=TestPulse_DAC*outgain*dacMultiplier[testdac]	endif	Variable x1, x2, x3, x4, base, pulse	x1=1	x2=round(0.98*numpnts(TestPulse_ADC)/8)	x3=round(5*numpnts(TestPulse_ADC)/8)	x4=round(6*numpnts(TestPulse_ADC)/8)-1	x1=pnt2x(TestPulse_ADC,x1)	x2=pnt2x(TestPulse_ADC,x2)	x3=pnt2x(TestPulse_ADC,x3)	x4=pnt2x(TestPulse_ADC,x4)	DoWindow /F TestPulseDisplay		//PauseUpdate//	execute the sample sequence	SampleData(adseq,daseq)//	extract waves from FIFOin	if (testtrigger>0)		TestPulse_ADC=FIFOin[2*p]*ingain	else		TestPulse_ADC=FIFOin*ingain	endif	ControlInfo /W=DataAcqPanel tp_bsub	if (V_value>0)		Wavestats /Q/R=[5,45] TestPulse_ADC		TestPulse_ADC-=V_avg	endif//	set display range//	Wavestats /Q/R=(x1,x2) TestPulse_ADC	Wavestats /Q TestPulse_ADC	miny=1.2*V_min//	Wavestats /Q/R=(x3,x4) TestPulse_ADC	Wavestats /Q TestPulse_ADC	maxy=1.2*V_max	miny-=maxy/10	if (miny>-0.2)		miny=-0.2	endif	if (maxy<0.2)		maxy=0.2	endif	Setaxis left, miny, maxy	ModifyGraph grid(left)=1	ModifyGraph tickUnit(bottom)=1	Label bottom "\\F'Helvetica'\\Z12\\f01Time (ms)"	WAVE adcType, dacType	SVAR unitsCurrent, unitsVoltage	if (adcType[testadc]==1)		Label left sprintf1s("\\F'Helvetica'\\Z12\\f01Current (%s)",unitsCurrent)	else		Label left sprintf1s("\\F'Helvetica'\\Z12\\f01Voltage (%s)",unitsVoltage)	endif	NVAR RSeal, tpamp	do		//PauseUpdate		SampleData(adseq,daseq)		if (testtrigger>0)			TestPulse_ADC=FIFOin[2*p]*ingain//			Setscale /P x, 0, sinttp, "ms", FIFOout, FIFOin		else			TestPulse_ADC=FIFOin*ingain		endif		ControlInfo /W=DataAcqPanel tp_bsub		if (V_value>0)			Wavestats /Q/R=[5,45] TestPulse_ADC			TestPulse_ADC-=V_avg		endif		base=mean(TestPulse_ADC,x1,x2)		pulse=mean(TestPulse_ADC,x3,x4)		if (adcType[testadc]==1 && dacType[testdac]==2)			// ADC channel is a current channel, DAC channel is a voltage channel			RSeal=tpamp/(pulse-base)		elseif (adcType[testadc]==2 && dacType[testdac]==1)			// output channel is a voltage channel			RSeal=(pulse-base)/tpamp		else			Printf "ADC and DAC channel for tet pulse are of same type, therefore the 'resistance' is unitless!\r"			RSeal=nan		endif		DoUpdate	while (HaltProcedures()<1)	DoWindow /F TestPulsePanel	SetDataFolder savDFEndFunction TPWinButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("TestPulseDisplay")<1)		Execute "TestPulseDisplay()"	else		DoWindow /F TestPulseDisplay		endif	if (wintype("DataAcqPanel")<1)		Execute "DataAcqPanel()"	else		DoWindow /F DataAcqPanel		endif	SetTPValues()EndFunction TPStartButtonProc(ctrlName) : ButtonControl	String ctrlName	StartTestPulse()EndFunction BsubCheck(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checkedEndFunction TPgateCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	if (checked<1)		checked=1	else		checked=0	endif	SetTPvalues()	BuildTestPulse()EndFunction TPampProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	SetTPvalues()	BuildTestPulse()EndFunction SetTPvalues()	NVAR tpamp=tpamp, tpgateamp=tpgateamp, tpdur=tpdur	ControlInfo tpgate_check	if (V_value>0)		tpamp=tpgateamp	endifEnd//_______________________DataPro DATA ACQUISITION MACROS_________________________//Function BuildStepPulse()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	NVAR dt=sintsp	NVAR spamp, spdur	Variable numsegs=3	Make /O /N=(numsegs) amplitude, duration	// amplitudes have units specified by unitsCurrent, unitsVoltage	// durations and sample interval have units of ms	amplitude[0]=0	amplitude[1]=spamp		// amplitude of second segment	amplitude[2]=0	duration[0]=0.2*spdur		// duration of second segment (ms)	duration[1]=spdur			// duration of second segment (ms)	duration[2]=0.5*spdur		// duration of second segment (ms)	// fixed and calculated variables	Variable totaldur=sum(duration)	Variable nSamples=ceil(totaldur/dt)+1	Make /O/N=(nSamples) StepPulse_DAC	Setscale /P x, 0, dt, "ms", StepPulse_DAC	Note /K StepPulse_DAC	ReplaceStringByKeyInWaveNote(StepPulse_DAC,"WAVETYPE","step3dac")	ReplaceStringByKeyInWaveNote(StepPulse_DAC,"TIME",time())	ReplaceStringByKeyInWaveNote(StepPulse_DAC,"STEP",num2str(spamp))	StepPulse_DAC=0	Variable first=0, last	Variable i	for (i=0;i<numsegs;i+=1)		if (i==numsegs-1)			last=nSamples-1		else			last=first+round(duration[i]/dt)-1		endif		StepPulse_DAC[first,last]=amplitude[i]		first=last+1	endfor	SetDataFolder savDFEndFunction BuildSynTTLPulse()	Silent 1	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	NVAR syntime, syndur	Variable first, last, sintms	Duplicate /O StepPulse_DAC SynPulse_TTL	Note /K SynPulse_TTL	ReplaceStringByKeyInWaveNote(SynPulse_TTL,"WAVETYPE","synttl")	ReplaceStringByKeyInWaveNote(SynPulse_TTL,"TIME",time())	SynPulse_TTL=0	sintms=deltax(SynPulse_TTL)	first=syntime/sintms	last=first+syndur/sintms	SynPulse_TTL[first,last]=1	SetDataFolder savDFEndFunction BuildFIFOWaves()	// Creates FIFOin and FIFOout waves in ADCDACcontrol data folder.		// Don't blather to the console	Silent 1		// Switch to the ADCDAC data folder	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		// Declare data folder vars we access	WAVE ttlon	//NVAR sint	//NVAR multdac	// the multipliers for each of the DAC channels	NVAR error	WAVE dacMultiplier		// The ADCDAC panel must exist for this to work, so check for it	if (!PanelExists("ADCDACControl"))		error=1		Abort "You need to open the ADC/DAC control panel first. Once it's open, you can hide it by double clicking the top bar."	endif		// get the DAC sequence	String daseq=GetDACSequence()	Variable seqLength=strlen(daseq)		// first build a single TTL pulse wave	// parent TTL waves should consist of zeros (low) and ones (high) only	Variable firstTime=1	// boolean	String thisTTLWaveNameRel	Variable wpts	// number of sample points in wave	Variable fifoSamplesTotal	Variable dt=0.05		// consensus sampling interval, ms	Variable i	for (i=0; i<4; i+=1)		if (ttlon[i]>0)			String pop=sprintf1d("ttlpopup_%d", i)			ControlInfo /W=ADCDACControl $pop			thisTTLWaveNameRel=S_value			if ( AreStringsEqual(thisTTLWaveNameRel,"_none_") )				Abort "You need to choose a TTL wave if you want an output on this channel."			endif			if (firstTime)				Duplicate /O $thisTTLWaveNameRel TTLoutwave				TTLoutwave=(2^i)*TTLoutwave				dt=deltax(TTLoutwave)				// calculate the multiplier for the number of points in the FIFO waves				wpts=numpnts(TTLoutwave)				fifoSamplesTotal=seqLength*wpts				// 	make the FIFO waves				Make /O /N=(fifoSamplesTotal) FIFOout FIFOin				FIFOout=0				FIFOin=0				firstTime=0			else				WAVE newwave=$thisTTLWaveNameRel				TTLoutwave+=(2^i)*newwave			endif		endif	endfor	// now assign values to FIFOout according to the DAC sequence	Variable iDACChannel	String thisDACWaveNameRel	Variable outgain	for (i=0; i<seqLength; i+=1)		iDACChannel=str2num(daseq[i])		if (iDACChannel<4)			sprintf pop "dacpopup_%d",iDACChannel			ControlInfo /W=ADCDACControl $pop			thisDACWaveNameRel=S_value			outgain=ComputeOutputGain(iDACChannel)		else			thisDACWaveNameRel="TTLoutwave"			outgain=1		endif		if (cmpstr(thisDACWaveNameRel,"_none_")==0)			FIFOout[i,;seqlength]=0		else			if (firstTime)				dt=deltax($thisDACWaveNameRel)				//	calculate the multiplier for the number of points in the FIFO waves				wpts=numpnts($thisDACWaveNameRel)				fifoSamplesTotal=seqLength*wpts				// 	make the FIFO waves				Make /O/N=(fifoSamplesTotal) FIFOout FIFOin				FIFOout=0				FIFOin=0				firstTime=0			else				if (dt!=deltax($thisDACWaveNameRel))					Beep					Abort "There is a sample interval mismatch in your DAC waves."				endif				if (wpts!=numpnts($thisDACWaveNameRel))					Beep					Abort "There is a mismatch in the number of points in your DAC and/or TTL waves."				endif			endif			// sprintf command, "multdac=multdac%s", daseq[i]			// Execute command			//String mdstr=sprintf1s("multdac%s", daseq[i])			//NVAR mdval=$mdstr, multdac=multdac			//NVAR mdval=$mdstr			//multdac=mdval			Wave thewave=$thisDACWaveNameRel			FIFOout[i,;seqLength]=thewave[floor(p/seqLength)]*outgain*dacMultiplier[iDACChannel]		endif	endfor	Setscale /P x, 0, dt/seqLength, "ms", FIFOout, FIFOin	Note /K FIFOin	ReplaceStringByKeyInWaveNote(FIFOin,"WAVETYPE","adc")	ReplaceStringByKeyInWaveNote(FIFOin,"TIME",time())	String newFIFOStepValue	if (seqlength>0)		newFIFOStepValue=StringByKeyInWaveNote($thisDACWaveNameRel,"STEP")	else		newFIFOStepValue=""	endif	ReplaceStringByKeyInWaveNote(FIFOin,"STEP",newFIFOStepValue)	SetDataFolder savDF	return dt		// return the sampling intervalEndFunction AcquireSweep(comment)	// Acquire a single sweep, which consists of n traces, each trace corresponding to a single 	// ADC channel.  Add the supplied comment to the acquired waves.	String comment		Silent 1	Wave browserNumber=GetAllBrowserNumbers()  // returns a free wave	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		NVAR iSweep	//NVAR sint	NVAR pn	NVAR error	WAVE FIFOin, FIFOout	WAVE /T adcBaseName	NVAR autoAnalyzeChecked	String thisWaveNameRel	//String savename	String thisstr, doit, whichadc	Variable leftmin, leftmax		DoWindow /F DataAcqPanel		//MakeITCseq()	BuildStepPulse()	BuildSynTTLPulse()	Variable dt=BuildFIFOWaves() 		// dt is sampling interval in ms	if (error>0)		error=1		Abort "data acquisition terminated"	endif		// Get the ADC and DAC sequences from the model	String daseq=GetDACSequence()	String adseq=GetADCSequence()	// Actually acquire the data for this sweep	SampleData(adseq,daseq) 	// raw acquired data is now in root:DP_ADCDACcontrol:FIFOin wave		// Do pN Subtraction, if called for	ControlInfo pn_check	if (V_value>0)		Duplicate /O FIFOout PNout		Duplicate /O FIFOin PNin		PNout=FIFOout/pn		FIFOout=PNout		Variable i		for (i=0; i<abs(pn); i+=1)			SampleData(adseq,daseq)			if (pn<0)				PNin+=FIFOin			else				PNin-=FIFOin			endif		endfor		FIFOin=PNin	endif		// This is a mistake, b/c user might already have DP browsers the way they want them	//// Bring the DP Browsers forward	//Variable nBrowsers=numpnts(browserNumber)	//for (i=0;i<nBrowsers;i+=1)	//	String browserNameThis=BrowserNameFromNumber(browserNumber[i])	//	DoWindow /F $browserNameThis	//endfor		//String browserName=BrowserNameFromNumber(browserNumber)	//DoWindow /F $browserName		// Get the number of ADC channels in use	Variable nADCInUse=GetNumADCChannelsInUse()		// Extract individual traces from FIFOin, store them in the appropriate waves	//String nameOfVarHoldingADCWaveBaseName	String units	Variable iADCChannel		// index of the relevant ADC channel	WAVE adcType	// wave s.t. adcType[i] gives the channel type-code for ADC i	SVAR unitsCurrent, unitsVoltage	Variable seqLength=GetSequenceLength()	Variable nSamplesPerTrace=numpnts(FIFOin)/seqLength	Variable ingain	Variable iTrace	for (iTrace=0; iTrace<nADCInUse; iTrace+=1)		SetDataFolder root:DP_ADCDACcontrol  // added by ALT 2012-05-23			// Must be here for adc1, adc2, etc. to get saved to waves with the right names		iADCChannel=str2num(adseq[iTrace])		//sprintf nameOfVarHoldingADCWaveBaseName "adcBaseName%d", iADCChannel		//SVAR base=$nameOfVarHoldingADCWaveBaseName		sprintf thisWaveNameRel "%s_%d", adcBaseName[iTrace], iSweep		//sprintf savename "%s.bwav", thisWaveNameRel		SetDataFolder root:		Make /O /N=(nSamplesPerTrace) $thisWaveNameRel		String thisWaveNameAbs="root:"+thisWaveNameRel		WAVE thisWave=$thisWaveNameAbs		Note thisWave, note(FIFOin)	// copy the wave note from FIFOin to the destination wave		ingain=ComputeInputGain(iADCChannel)		thisWave=FIFOin[seqLength*p+iTrace]*ingain	// copy this trace out of the FIFO, and scale it by the gain		Setscale /P x, 0, dt, "ms", thisWave		if (adcType[iADCChannel]==1)			// current channel			units=unitsCurrent		else			// voltage channel			units=unitsVoltage		endif					SetScale d 0,0,units, thisWave		ReplaceStringByKeyInWaveNote(thisWave,"COMMENTS",comment)		//Save /O /P=home thisWave as savename	endfor	// This needs to be smarter, since we don't know what traces they are showing 	// in the DP browser.	////	// Make sure the traces are shown if they were acquired//	if ( nADCInUse>=1 )//		SetTraceAChecked(browserNumber,1)//	endif//	if ( nADCInUse>=2 )//		SetTraceBChecked(browserNumber,1)//	endif		// Update the sweep number in the DP Browsers	Variable nBrowsers=numpnts(browserNumber)	for (i=0;i<nBrowsers;i+=1)		SetICurrentSweepAndSyncView(browserNumber[i],iSweep)	endfor		// Update some of the acquisition counters	iSweep+=1	//iSweepPrevious=iSweep-1		//// Bring the data acquistion panel forward, for some reason	//DoWindow /F DataAcqPanel			// Update the windows, so user can see the new sweep	DoUpdate	// If called for, run the per-user function	if (autoAnalyzeChecked)		AutoAnalyze()		DoUpdate	endif	// Restore the original data folder	SetDataFolder savDFEnd//Function EPhys_Image()//	Variable sidx_handle, status, exposure, canceled//	String message, command//	if (ccd_opened<1)//		SIDX_Begin()//	endif////	if (sidx_handle==  4.306e+07)////		SIDX_Begin_Auto()////	endif////	SIDX_Setup()//	image_trig=1//	SIDX_Setup_Auto()//	image_roi=2		// zero for full frame, one for specific ROI, two for ROI with background//	im_plane=0//	FluorescenceON()//	Execute "Sleep /S 0.1"//	sprintf command, "Image_Stack(image_trig,0)"//	Execute command//	print "done with image stack"//	sprintf command, "Get_DFoverF_from_Stack(%d)", iSweepPrevious//	Execute command//	sprintf command, "Append_DFoverF(%d)", iSweepPrevious//	Execute command//	FluorescenceOFF()//	printf "%s%d: Image with EPhys done\r", imageseq_name, iSweepPrevious//EndFunction DataButtonProc(ctrlName) : ButtonControl	// Raise or create the three windows used for data acquisition	String ctrlName		Execute "RaiseOrCreatePanel(\"ADCDACControl\")"	Execute "RaiseOrCreatePanel(\"DataAcq\")"	Execute "RaiseOrCreateDataProBrowser()"EndFunction DataAcqButtonProc(ctrlName) : ButtonControl	String ctrlName	AcquireTrial()EndFunction AcquireTrial()	// Acquire a single trial, which is composed of n sweeps	String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	Variable start_time, last_time	String temp_comments, doit	NVAR nSweepsPerTrial	NVAR sweep_interval	NVAR error	String comment	Variable iSweepWithinTrial	for (iSweepWithinTrial=0;iSweepWithinTrial<nSweepsPerTrial; iSweepWithinTrial+=1)			if (iSweepWithinTrial<1)			start_time = DateTime		else			start_time = last_time + sweep_interval		endif		if (nSweepsPerTrial==1)			sprintf comment "stim %d of %d",iSweepWithinTrial+1,nSweepsPerTrial		else			sprintf comment "stim %d of %d, with inter-stim-interval of %d",iSweepWithinTrial+1,nSweepsPerTrial,sweep_interval		endif		sprintf doit, "Sleep /A %s", Secs2Time(start_time,3)		Execute doit		AcquireSweep(comment)  // this calls DoUpdate() inside		if (error>0)			error=0			Abort 		endif		last_time = start_time		//SaveStimHistory()	endfor	//comment=""	SetDataFolder savDFEndFunction DPampProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName//	SetDPvalues()	BuildStepPulse()EndFunction DPdurCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	if (cmpstr(ctrlName,"spdur_check0")!=0)		CheckBox spdur_check0 value=0		CheckBox spdur_check1 value=1	else		CheckBox spdur_check1 value=0		CheckBox spdur_check0 value=1	endif//	SetDPvalues()	BuildStepPulse()EndFunction DPdurProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName//	SetDPvalues()	BuildStepPulse()End//______________________DataPro Imaging PROCEDURES__________________________//Function ImagingButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("ImagingPanel")<1)		Execute "ImagingPanel()"	else		DoWindow /F ImagingPanel		endifEndFunction FluONButtonProc(ctrlName) : ButtonControl	String ctrlName	FluorescenceON()EndFunction FluorescenceON()	String command	NVAR wheel=fluo_on_wheel	SetVDTPort("COM1")	Execute "VDTWriteBinary 238"	sprintf command "VDTWriteBinary 8%d", wheel	Execute command//	print "fluorescence on"EndFunction FluOFFButtonProc(ctrlName) : ButtonControl	String ctrlName	FluorescenceOFF()EndFunction FluorescenceOFF()	SetVDTPort("COM1")	Execute "VDTWriteBinary 238"	Execute "VDTWriteBinary 80"//	print "fluorescence off"EndFunction SetVDTPort(name)	String name	Execute "VDTGetPortList"	SVAR port=S_VDT	NVAR imaging=imaging	String command	imaging=1	if (cmpstr(port,"")==0)		imaging=0		Abort "A serial port could not be located"	else		sprintf command, "VDTOperationsPort %s", name		Execute command	endifEndFunction ImagingCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	NVAR imaging=imaging	Execute "VDTGetPortList"	SVAR port=S_VDT	if (checked>0)		imaging=1		SetVDTPort("COM1")	else		imaging=0	endifEnd//______________________DataPro Data Acquisition HISTORY__________________________////________________________written by Don Cooper________________________________////Function SaveStimHistory()//	String savDF=GetDataFolder(1)//	NewDataFolder /O/S root:DP_ADCDACcontrol//	Variable StimHsize, wavenum//	String theMultDac, theDacGain, theDacPopup//	NVAR nSweepsPerTrial//	NVAR iSweep=iSweep, HoldV=HoldV,NumRepeats=NumRepeats, IStimI=IStimI, TempV=TempV, Rseal=Rseal//	NVAR MadeStimHist=MadeStimHist, dacgain1=dacgain1, spamp=spamp, spdur=spdur//	NVAR dacgain2=dacgain2, pn=pn//	//SVAR wave_comments//	String daseq=GetDACSequence()////	String history="StimHistory"////  ***daseq*** = string listing which DAC's are checked          //     sprintf theMultDac "multdac%s", daseq[0]//     sprintf theDacGain "dacgain%s", daseq[0]//     sprintf theDacPopup "dacpopup_%s", daseq[0]//     NVAR theMD=$theMultDac, theDG=$theDacGain//     wavenum=iSweep-1//// make a table... but check to see if it's already been made first//	if (exists("StimHistory")!=1)//		Make/T/O/N=(2,11) StimHistory//		StimHistory[0][0]="Stimulus Wave"//		StimHistory[0][1]="Wave Multiplier"//		StimHistory[0][2]="Holding Potential"//		StimHistory[0][3]="Gain"//		StimHistory[0][4]="Current Step"		//for step_pulses//		StimHistory[0][5]="Step Duration"		//for step_pulses//		StimHistory[0][6]="pN"//		StimHistory[0][7]="Comments"//		StimHistory[0][8]="Time"//		StimHistory[0][9]="Temp"//		Stimhistory[0][10]="Seal"//	endif////	insert appropriate row(s) in table//	StimHsize= dimsize(StimHistory,0)//	if (StimHsize<=wavenum)//		if (StimHsize==wavenum)//			InsertPoints wavenum,1, StimHistory//		else//			InsertPoints StimHsize,(1+wavenum-StimHsize), StimHistory//		endif//	endif//// enter all the other data //	ControlInfo /W=ADCDACControl $theDacPopup//	StimHistory[wavenum][0]=S_Value                   		//the stimulus wave//	StimHistory[wavenum][1]=num2str(theMD)         	//the wave multiplier//	StimHistory[wavenum][2]=num2str(HoldV)     		//the holding potential//	StimHistory[wavenum][3]=num2str(theDG)          	//gain on stimulator//	StimHistory[wavenum][6]=num2str(pn)             	//pN//	StimHistory[wavenum][7]=""		            		//comments//	StimHistory[wavenum][8]=time()                    		//approx. time of data acqisition//	StimHistory[wavenum][9]=num2str(TempV)		//Temperature//	StimHistory[wavenum][10]=num2str(RSeal)		//SR//	if (cmpstr(S_value,"StepPulse_DAC")==0)			//if the stim is a "step pulse"...//		StimHistory[wavenum][4]=num2str(spamp)     		 //the current step//		StimHistory[wavenum][5]=num2str(spdur)     		 //step duration//	else//		StimHistory[wavenum][4]=""     		 //don't put anything//		StimHistory[wavenum][5]=""     		 //don't put anything//	endif//	SetDataFolder savDF//End//______________________DataPro Data Acquisition PROCEDURES__________________________////Function MakeITCseq()//	// Determines the sequencing strings required by the ITC functions for proper A/D and D/A.//	// Reads: dacon, ttlon, adcon//	// Writes: daseq, adseq, nADCInUse, nDACInUse, seqlength//	//	// Shut up//	Silent 1//	//	// Change to the ADCDACcontrol data folder//	String savDF=GetDataFolder(1)//	NewDataFolder /O/S root:DP_ADCDACcontrol////	// Declare the DF vars we need//	NVAR nDACInUse, nADCInUse, seqlength//	SVAR daseq, adseq//	WAVE dacon, ttlon, adcon////	// Build up the strings that the ITC functions use to sequence the//	// inputs and outputs	//	daseq=""//	adseq=""//	Variable i//	for (i=0; i<4; i+=1)//		if (dacon[i]>0)//			daseq+=num2str(i)//		endif//	endfor//	for (i=0; i<4; i+=1)//		if (ttlon[i]>0)//			daseq+="D"//			break//		endif//	endfor//	for (i=0; i<8; i+=1)//		if (adcon[i]>0)//			adseq+=num2str(i)//		endif//	endfor//	//	// Because the DA and AD sequences must be the same length, we find the least common multiple//	// of the number of channels in use, and duplicate the sequences as needed.//	// (But why not use Noops?  Especially if, for instance, nDACInUse is zero?)//	nDACInUse=strlen(daseq)//	nADCInUse=strlen(adseq)//	seqlength=LCM(nDACInUse, nADCInUse)	//	calculate the length of the AD and DA sequence strings (must be the same)//	String shortdaseq, shortadseq//	if (nDACInUse!=nADCInUse)//		shortdaseq=daseq; shortadseq=adseq//		daseq=""; adseq=""//		for (i=0; i<seqlength/nDACInUse; i+=1)//			daseq+=shortdaseq//		endfor//		for (i=0; i<seqlength/nADCInUse; i+=1)//			adseq+=shortadseq//		endfor//	endif//	//	// Restore the original DF//	SetDataFolder savDF//EndFunction SampleData(adseq,daseq)	// The heart of the data acquisition.  On exit, the raw acquired data is in the wave	// root:DP_ADCDACcontrol:FIFOin .	String adseq	String daseq		String savDF=GetDataFolder(1)	NewDataFolder /O/S root:DP_ADCDACcontrol	NVAR itc	NVAR usPerDigitizerClockTick	WAVE FIFOin, FIFOout	Variable sintpts	String commandLine	if (itc==0)		WAVE StepPulse_DAC		FIFOin=sin(0.05*x)+gnoise(0.1)+StepPulse_DAC+5	elseif (itc==16)		Execute "ITC16StimClear 0"		//Execute "ITC16Seq daseq, adseq"		sprintf commandLine "ITC16Seq \"%s\", \"%s\"", daseq, adseq		Execute commandLine		sintpts=deltax(FIFOout)*1000/usPerDigitizerClockTick		sprintf commandLine, "ITC16StimAndSample FIFOout, FIFOin, %d, 14", sintpts		Execute commandLine		Execute "ITC16StopAcq"	elseif (itc==18)		// might need to change acqflags to 14 to make this work		//Execute "ITC18StimClear 0"  // ALT, 2012/05/23		//Execute "ITC18Seq daseq, adseq"		sprintf commandLine "ITC18Seq \"%s\", \"%s\"", daseq, adseq		Execute commandLine		sintpts=deltax(FIFOout)*1000/usPerDigitizerClockTick		Execute "ITC18Stim FIFOout"		sprintf commandLine, "ITC18StartAcq %d,2,0", sintpts		Execute commandLine		Execute "ITC18Samp FIFOin"		Execute "ITC18StopAcq"	else		// do nothing	endif	SetDataFolder savDFEnd//___________________________DataPro CLAMP MODE___________________________//Function ToggleClampButtonProc(ctrlName) : ButtonControl	String ctrlName	print "switch all clamp modes together - not yet implemented"	Variable i=0//	do//		SwitchClampMode(i,x)//		i+=1//	while(i<8)EndFunction HandleADCChannelModePopupMenu(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	Variable iChannel		iChannel=str2num(ctrlName[strlen(ctrlName)-1])	SwitchADCChannelMode(iChannel,popNum)EndFunction SwitchADCChannelMode(iChannel,mode)	// Switches the indicated ADC channel to the given mode.  Currently, the mode can be 1 (==current)	// or 2 (==voltage)	Variable iChannel, mode		String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		WAVE adcType	WAVE adcgain, adcgain_voltage, adcgain_current	adcType[iChannel]=mode	if (mode==1)		adcgain[iChannel]=adcgain_current[iChannel]	else		adcgain[iChannel]=adcgain_voltage[iChannel]	endif	SyncADCGainSetVariableToModel(iChannel)	SetDataFolder savDFEndFunction HandleDACChannelModePopupMenu(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	Variable iChannel	iChannel=str2num(ctrlName[strlen(ctrlName)-1])	SwitchDACChannelMode(iChannel,popNum)EndFunction SwitchDACChannelMode(iChannel,mode)	// Switches the indicated DAC channel to the given mode.  Currently, the mode can be 1 (==current)	// or 2 (==voltage)	Variable iChannel, mode	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacType	WAVE dacgain,dacgain_voltage, dacgain_current	dacType[iChannel]=mode	if (mode==1)		dacgain[iChannel]=dacgain_current[iChannel]	else		dacgain[iChannel]=dacgain_voltage[iChannel]	endif	SyncDACGainSetVariableToModel(iChannel)	SetDataFolder savDFEnd//______________________DataPro ADC AND DAC CONTROL____________________////Function SetDACGain(iDACChannel)//	Variable iDACChannel//	String savDF=GetDataFolder(1)//	SetDataFolder root:DP_ADCDACcontrol//	WAVE dacgain//	NVAR pointsPerVoltDAC//	NVAR dacgain0=dacgain0, dacgain1=dacgain1, dacgain2=dacgain2, dacgain3=dacgain3 //	dacgain[0]=dacgain0//	dacgain[1]=dacgain1//	dacgain[2]=dacgain2//	dacgain[3]=dacgain3//	Variable usedacgain=dacgain[iDACChannel]//	Variable outgain=pointsPerVoltDAC/usedacgain	// has units points/unitsVoltage (VC) or points/unitsCurrent (CC)//	SetDataFolder savDF//	return outgain//EndFunction SyncDACGainWaveToVars()	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacgain	NVAR dacgain0=dacgain0, dacgain1=dacgain1, dacgain2=dacgain2, dacgain3=dacgain3 	dacgain[0]=dacgain0	dacgain[1]=dacgain1	dacgain[2]=dacgain2	dacgain[3]=dacgain3	SetDataFolder savDFEndFunction ComputeOutputGain(iDACChannel)	// Calculates the output gain (in points per native unit) based on the gain for the given 	// channel and pointsPerVoltDAC.	Variable iDACChannel	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacgain	// (native units)/V	Variable pointsPerVoltDAC=32768/10.24	// points/V	//NVAR pointsPerVoltDAC	// points/V	Variable outgain=pointsPerVoltDAC/dacgain[iDACChannel]	// points/(native unit)	SetDataFolder savDF	return outgainEnd//Function SetADCGain(iADCChannel)//	// Syncs the adcgain wave to the adcgain<i> variables.//	// Also sets ingain based on the gain for the given channel and pointsPerVoltADC.//	Variable iADCChannel//	SyncADCGainWaveToVars()//	return ComputeInputGain(iADCChannel)//End//Function SyncADCGainWaveToVars()//	// Syncs the adcgain wave to the adcgain<i> variables.//	Variable iADCChannel//	String savDF=GetDataFolder(1)//	SetDataFolder root:DP_ADCDACcontrol//	//	// these are the "inputs" to this procedure//	NVAR adcgain0, adcgain1, adcgain2, adcgain3//	NVAR adcgain4, adcgain5, adcgain6, adcgain7//	// these are the outputs of this procedure//	WAVE adcgain//	//	// do what's described above//	adcgain[0]=adcgain0//	adcgain[1]=adcgain1//	adcgain[2]=adcgain2//	adcgain[3]=adcgain3//	adcgain[4]=adcgain4//	adcgain[5]=adcgain5//	adcgain[6]=adcgain6//	adcgain[7]=adcgain7//	//	// Restore the DF//	SetDataFolder savDF//EndFunction ComputeInputGain(iADCChannel)	// Calculates the input gain (in native units per point) based on the gain for the given 	// channel and pointsPerVoltADC.	Variable iADCChannel		// Set the DF	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		// these are the "inputs" to this procedure	Variable pointsPerVoltADC=32768/10.24		// points/V	Wave adcgain	// V/(native unit)		// do what's described above	Variable ingain=1/(adcgain[iADCChannel]*pointsPerVoltADC)		// (native units)/point	// Restore the DF		SetDataFolder savDF	// Exit	return ingainEndFunction HandleADCGainSetVariable(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE adcType	WAVE adcgain	WAVE adcgain_current, adcgain_voltage		Variable i=str2num(ctrlName[7])  // ADC channel index	if (adcType[i]==1)		adcgain_current[i]=varNum	else		adcgain_voltage[i]=varNum			endif	adcgain[i]=varNum		SetDataFolder savDFEndFunction SyncADCGainSetVariableToModel(i)	Variable i 	// ADC channel index	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE adcgain	String setVariableName=sprintf1d("adcGain%dSetVariable",i)	SetVariable $setVariableName value=_NUM:adcgain[i]	SetDataFolder savDF	EndFunction HandleDACGainSetVariable(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		WAVE dacType	WAVE dacgain	WAVE dacgain_current, dacgain_voltage	Variable i=str2num(ctrlName[7])  // DAC channel index	if (dacType[i]==1)		dacgain_current[i]=varNum	else		dacgain_voltage[i]=varNum			endif	dacgain[i]=varNum			SetDataFolder savDFEndFunction HandleDACMultiplierSetVariable(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol		WAVE dacMultiplier	Variable i=str2num(ctrlName[13])  // DAC channel index	dacMultiplier[i]=varNum			SetDataFolder savDFEndFunction SyncDACGainSetVariableToModel(i)	Variable i 	// DAC channel index	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE dacgain	String setVariableName=sprintf1d("dacGain%dSetVariable",i)	SetVariable $setVariableName value=_NUM:dacgain[i]	SetDataFolder savDF	EndFunction ADC_DACButtonProc(ctrlName) : ButtonControl	String ctrlName	RaiseOrCreatePanel("ADCDACControl")EndFunction ADCDACcheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable box	box=str2num(ctrlName[6])	String wavetochange	sprintf wavetochange, "%son", ctrlName[0,2]	Wave adcdacttlon = $wavetochange	adcdacttlon[box]=checked	SetDataFolder savDFEndFunction SaveControlButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "SaveControls()"EndProc SaveControls()	Variable ControlFileVar	String pop	Variable i	Open ControlFileVar  as "ADCoutputFile"	i=0	do		fprintf ControlFileVar, "%d\r%g\r%s\r", adcon[i], adcgain[i], adcBaseName[i]		i+=1	while(i<8)	i=0	do		fprintf ControlFileVar, "%d\r%g\r", dacon[i], dacgain[i]		sprintf pop "dacpopup_%d", i		ControlInfo /W=ADCDACControl $pop		fprintf ControlFileVar, "%s\r", S_value		i+=1	while(i<4)	i=0	do		fprintf ControlFileVar, "%d\r", ttlon[i]		sprintf pop "ttlpopup_%d", i		ControlInfo /W=ADCDACControl $pop		fprintf ControlFileVar, "%s\r", S_value		i+=1	while(i<4)	Close ControlFileVarEndFunction ReadControlButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "ReadControls()"EndProc ReadControls()	Variable ControlFileVar	String instring, pop, box, list, thestr, msg	Variable i, j, x	Open /R ControlFileVar	i=0	do		FReadLine ControlFileVar, instring		adcon[i]=str2num(instring)		sprintf box, "adcon_%d", i		CheckBox $box win=ADCDACControl, value=adcon[i]		FReadLine ControlFileVar, instring		adcgain[i]=str2num(instring)		FReadLine ControlFileVar, instring		x=strlen(instring)-2		adcBaseName[i]=instring[0,x]		i+=1	while(i<8)	i=0	do		FReadLine ControlFileVar, instring		dacon[i]=str2num(instring)		sprintf box, "dacon_%d", i		CheckBox $box win=ADCDACControl, value=dacon[i]		FReadLine ControlFileVar, instring		dacgain[i]=str2num(instring)		FReadLine ControlFileVar, instring		instring=instring[0,strlen(instring)-2]		list="_none_;"+Wavelist("*_DAC",";","")		j=1		do			thestr=GetStrFromList(list,j-1,";")			if (cmpstr(thestr,instring)==0)				break			endif			if (strlen(thestr)==0)				sprintf msg, "DAC wave %s not found for DAC%d.", instring, i				Abort msg			endif			j+=1		while(1)		sprintf pop "dacpopup_%d", i		PopupMenu $pop mode=j		i+=1	while(i<4)	i=0	do		FReadLine ControlFileVar, instring		ttlon[i]=str2num(instring)		sprintf box, "ttlon_%d", i		CheckBox $box win=ADCDACControl, value=ttlon[i]		FReadLine ControlFileVar, instring		instring=instring[0,strlen(instring)-2]		list="_none_;"+Wavelist("*_TTL",";","")		j=1		do			thestr=GetStrFromList(list,j-1,";")			if (cmpstr(thestr,instring)==0)				break			endif			if (strlen(thestr)==0)				sprintf msg, "TTL wave %s not found for TTL%d.", instring, i				Abort msg			endif			j+=1		while(1)		sprintf pop "ttlpopup_%d", i		PopupMenu $pop mode=j		i+=1	while(i<4)	Wave2Vars("dacgain","dacgain",4)	Wave2Vars("adcgain","adcgain",8)	//Wave2Vars("adcBaseName","adcBaseName",8)	Close ControlFileVarEnd//__________________________DataPro DAC PULSE BUILER___________________________//Function DACBuilderButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("DACPulses")<1)		Execute "DACPulses()"	else		DoWindow /F DACPulses		endifEndFunction ReadwaveButtonProc(ctrlName) : ButtonControl	String ctrlName	LoadWaveEndFunction SaveDACButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "SaveDAC()"EndFunction SaveDAC(namestr)	String namestr	Prompt namestr, "Enter a wavename with an extension _DAC or _TTL:"	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String filestr	filestr=namestr+".bwav"	Duplicate /O NewDAC $namestr	Save/C $namestr as filestr	SetDataFolder savDFEndFunction FiveSegButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("FiveSegBuilder")<1)		Execute "FiveSegBuilder()"		Execute "StepVarChange()"	else		DoWindow /F FiveSegBuilder	endifEndFunction StepVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "StepVarChange()"End//Function FromFileCheckProc(ctrlName,checked) : CheckBoxControl//	String ctrlName//	Variable checked//	String savDF=GetDataFolder(1)//	SetDataFolder root:DP_ADCDACcontrol//	NVAR ffseg=ffseg//	String doit//	if (checked>0)//		ffseg=str2num(ctrlName[3])////		print ffseg//		Execute "FFWaveInput()"//	else//		Execute "StepVarChange()"//	endif//	SetDataFolder savDF//End////Proc FFWaveInput(waveinput)//	String waveinput//	Prompt waveinput, "Select wave to insert:", popup Wavelist("*_DAC",";","")+Wavelist("*_TTL",";","")//	String waveoutput//	sprintf waveoutput, "ffwave%d", ffseg//	if (deltax($waveinput)!=deltax(Step5DAC))//		CheckBox ff_2 win=FiveSegBuilder, value=0//		Abort "Sample Interval Mismatch"//	else//		Duplicate /O $waveinput $waveoutput//		StepVarChange()//	endif//EndProc StepVarChange()	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable i, first, last, totaldur, firstp, lastp	String ffstr, notestr	Vars2Wave("stepdur","duration",5)	Vars2Wave("stepamp","amplitude",5)	PauseUpdate	totaldur=0	i=0	do		sprintf ffstr, "ff_%d", i		ControlInfo $ffstr		if (V_value>0)			sprintf ffstr, "ffwave%d", i			duration[i]=numpnts($ffstr)*deltax($ffstr)			//print duration[i]			Wave2Vars("duration","stepdur",5)		endif		totaldur+=duration[i]		i+=1	while(i<5)	print totaldur, sintpb	Redimension /N=(totaldur/sintpb) Step5DAC	Setscale /P x, 0, sintpb, "ms", Step5DAC	Note /K Step5DAC	ReplaceStringByKeyInWaveNote(Step5DAC,"WAVETYPE","step5dac")	ReplaceStringByKeyInWaveNote(Step5DAC,"TIME",time())	ReplaceStringByKeyInWaveNote(Step5DAC,"STEP",num2str(amplitude[1]))	first=0	i=0	do		last=first+duration[i]		sprintf ffstr, "ff_%d", i		ControlInfo $ffstr		if (V_value<1)			Step5DAC(first,last)=amplitude[i]		else			sprintf ffstr, "ffwave%d", i			amplitude[i]=0			firstp=x2pnt(Step5DAC, first)			lastp=x2pnt(Step5DAC, last)			Step5DAC[firstp,lastp]=$ffstr[p-firstp]			Wave2Vars("amplitude","stepamp",5)		endif		first=last+sintpb		sprintf notestr, "AMP%d", i		ReplaceStringByKeyInWaveNote(Step5DAC,notestr,num2str(amplitude[i]))		sprintf notestr, "DUR%d", i		ReplaceStringByKeyInWaveNote(Step5DAC,notestr,num2str(duration[i]))		i+=1	while(i<5)	ResumeUpdate	Duplicate /O Step5DAC NewDAC	SetDataFolder savDFEndFunction EditFiveSegWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String showstr	sprintf showstr, "ShowFiveSegWave(\"%s\")", popStr	Execute showstr	SetDataFolder savDFEndProc ShowFiveSegWave(popstr)	String popstr	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		stepdur0=10; stepdur1=10; stepdur2=10; stepdur3=10; stepdur4=10		stepamp1=10; stepamp3=10; sintpb=0.01		StepVarChange()	else		keyval=StringByKeyInWaveNote($popstr,"WAVETYPE")		if (cmpstr(keyval,"step5dac")==0)			sintpb=deltax($popstr)			do				sprintf keyword, "DUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				sprintf keyword, "AMP%d", i				amplitude[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<5)			Wave2Vars("duration", "stepdur", 5)			Wave2Vars("amplitude", "stepamp", 5)			StepVarChange()		else			Abort("This is not a five segment wave; choose another")		endif	endif	SetDataFolder savDFEndFunction TrainButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("TrainBuilder")<1)		Execute "TrainVarChange()"		Execute "TrainBuilder()"	else		DoWindow /F TrainBuilder	endifEndFunction TrainVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "TrainVarChange()"EndProc TrainVarChange()	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	Variable i, j, first, last, totaldur	String notestr	traindur1=(trainnum/trainfreq)*1000	Vars2Wave("traindur","duration",3)	PauseUpdate	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<3)	Redimension /N=(totaldur/sintpb) TrainDAC	Setscale /P x, 0, sintpb, "ms", TrainDAC	Note /K TrainDAC	ReplaceStringByKeyInWaveNote(TrainDAC,"WAVETYPE","traindac")	ReplaceStringByKeyInWaveNote(TrainDAC,"TIME",time())	TrainDAC=trainbase	first=0	i=0	do		if (i==1)			j=0			do				last=first+traindur				TrainDAC(first,last)=trainbase+trainamp				first+=1000/trainfreq+sintpb				j+=1			while(j<trainnum)		else			last=first+duration[i]			TrainDAC(first,last)=trainbase		endif		first=last+sintpb		sprintf notestr, "TRAINDUR%d", i		ReplaceStringByKeyInWaveNote(TrainDAC,notestr, num2str(duration[i]))		i+=1	while(i<3)	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINNUM", num2str(trainnum))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINFREQ", num2str(trainfreq))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINBASE", num2str(trainbase))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINAMP", num2str(trainamp))	ReplaceStringByKeyInWaveNote(TrainDAC,"TRAINUPDUR", num2str(traindur))	ResumeUpdate	Duplicate /O TrainDAC NewDAC	SetDataFolder savDFEndFunction EditTrainWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowTrainWave(\"%s\")", popStr	Execute showstrEndProc ShowTrainWave(popstr)	String popstr	String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		traindur0=10; traindur1=10; traindur2=10; trainnum=10		trainfreq=10; trainamp=10; trainbase=0; traindur=2; sintpb=0.01		TrainVarChange()	else		keyval=StringByKeyInWaveNote($popstr, "WAVETYPE")		if (cmpstr(keyval,"traindac")==0)			sintpb=deltax($popstr)			do				sprintf keyword, "TRAINDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "traindur", 3)			sprintf keyword, "TRAINNUM"			trainnum=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINFREQ"			trainfreq=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINAMP"			trainamp=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINBASE"			trainbase=NumberByKeyInWaveNote($popstr,keyword)			sprintf keyword, "TRAINUPDUR"			traindur=NumberByKeyInWaveNote($popstr,keyword)			TrainVarChange()		else			Abort("This is not a train wave; choose another")		endif	endif	SetDataFolder savDFEndFunction RampButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("RampBuilder")<1)		Execute "RampVarChange()"		Execute "RampBuilder()"	else		DoWindow /F RampBuilder	endifEndFunction RampVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "RampVarChange()"EndProc RampVarChange()	String savDF= GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol:	Variable i, j, first, last, totaldur, slope	String notestr	Vars2Wave("rampdur","duration",3)	Vars2Wave("rampamp","amplitude",3)//	amplitude[0]=amplitude[1]//	rampamp0=rampamp1	PauseUpdate	totaldur=0	i=1	do		totaldur+=duration[i]		i+=1	while(i<5)	Redimension /N=(totaldur/sintpb) RampDAC	Setscale /P x, 0, sintpb, "ms", RampDAC	Note /K RampDAC	ReplaceStringByKeyInWaveNote(RampDAC,"WAVETYPE","rampdac")	ReplaceStringByKeyInWaveNote(RampDAC,"TIME",time())	slope=(rampamp3-rampamp1)/rampdur2	first=0	i=1	do		if (i==2)			last=first+rampdur2			RampDAC(first,last)=rampamp1+slope*(x-rampdur1)		else			last=first+duration[i]			RampDAC(first,last)=amplitude[i]		endif		first=last+sintpb		sprintf notestr, "RAMPDUR%d", i		ReplaceStringByKeyInWaveNote(RampDAC,notestr, num2str(duration[i]))		sprintf notestr, "RAMPAMP%d", i		ReplaceStringByKeyInWaveNote(RampDAC,notestr, num2str(amplitude[i]))		i+=1	while(i<5)	ResumeUpdate	Duplicate /O RampDAC NewDAC	SetDataFolder savDFEndFunction EditRampWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowRampWave(\"%s\")", popStr	Execute showstrEndProc ShowRampWave(popstr)	String popstr	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		rampdur0=10; rampdur1=50; rampdur2=10		rampamp1=-10; rampamp2=10; sintpb=0.01		RampVarChange()	else		keyval=StringByKeyInWaveNote("WAVETYPE",$popstr)		if (cmpstr(keyval,"rampdac")==0)			sintpb=deltax($popstr)			do				sprintf keyword, "RAMPDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				sprintf keyword, "RAMPAMP%d", i				amplitude[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "rampdur", 3)			Wave2Vars("amplitude", "rampamp", 3)			RampVarChange()		else			Abort("This is not a ramp wave; choose another")		endif	endifEndFunction PSCButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("PSCBuilder")<1)		Execute "PSCVarChange()"		Execute "PSCBuilder()"	else		DoWindow /F PSCBuilder	endifEndFunction PSCVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "PSCVarChange()"EndProc PSCVarChange()	Variable i, j, first, last, totaldur, max, scale, rise, decay1, decay2, err	String notestr, savDF	savDF=GetDataFolder(1)	SetDataFolder "root:DP_ADCDACcontrol"	Vars2Wave("pscdur","duration",3)	PauseUpdate	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<3)	Redimension /N=(totaldur/sintpb) PSCDAC	Setscale /P x, 0, sintpb, "ms", PSCDAC	Note /K PSCDAC	ReplaceStringByKeyInWaveNote(PSCDAC,"WAVETYPE","pscdac")	ReplaceStringByKeyInWaveNote(PSCDAC,"TIME",time())	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCAMP",num2str(pscamp))	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCTAUR",num2str(psctaur))	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCTAUD1",num2str(psctaud1))	ReplaceStringByKeyInWaveNote(PSCDAC,"PSCTAUD2",num2str(psctaud2))	ReplaceStringByKeyInWaveNote(PSCDAC,"WTTD2",num2str(wttd2))	scale=1.37		// correct value is unique for each psc wave; adjusted in loop below	first=0	i=0	do		if (i==1)			last=first+pscdur1			PSCDAC(first,last)=pscamp*scale*-exp((pscdur0-x)/psctaur)			PSCDAC(first,last)+=(1-wttd2)*pscamp*scale*exp((pscdur0-x)/psctaud1)			PSCDAC(first,last)+=wttd2*pscamp*scale*exp((pscdur0-x)/psctaud2)			do				Wavestats /Q/R=(first,last) PSCDAC				if (abs(V_min)<V_max)					err=(V_max-pscamp)/pscamp				else					err=(V_min-pscamp)/pscamp				endif				PSCDAC=PSCDAC*(1-err)			while(abs(err)>0.001)		else			last=first+duration[i]			PSCDAC(first,last)=0		endif		first=last+sintpb		sprintf notestr, "PSCDUR%d", i		ReplaceStringByKeyInWaveNote(PSCDAC,notestr,num2str(duration[i]))		i+=1	while(i<3)	ResumeUpdate	Duplicate /O PSCDAC NewDAC	SetDataFolder savDFEndFunction EditPSCWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowPSCWave(\"%s\")", popStr	Execute showstrEndProc ShowPSCWave(popstr)	String popstr	String keyword, keyval, savDF	Variable i	savDF=GetDataFolder(1)	SetDataFolder "DP_ADCDACcontrol"	if (cmpstr(popstr,"_New_")==0)		pscdur0=10; pscdur1=50; pscdur2=10; pscamp=10		psctaur=0.2; psctaud1=2; psctaud2=10; wttd2=0.5; sintpb=0.01		PSCVarChange()	else		keyval=StringByKeyInWaveNote("WAVETYPE", $popstr)		if (cmpstr(keyval,"pscdac")==0)			pscamp=NumberByKeyInWaveNote($popstr,"PSCAMP")			psctaur=NumberByKeyInWaveNote($popstr,"PSCTAUR")			psctaud1=NumberByKeyInWaveNote($popstr,"PSCTAUD1")			psctaud2=NumberByKeyInWaveNote($popstr,"PSCTAUD2")			wttd2=NumberByKeyInWaveNote($popstr,"WTTD2")			sintpb=deltax($popstr)			do				sprintf keyword, "PSCDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "pscdur", 3)			PSCVarChange()		else			Abort("This is not a PSC wave; choose another")		endif	endif	SetDataFolder savDFEndFunction SineButtonProc(ctrlName) : ButtonControl	String ctrlName	if (wintype("SineBuilder")<1)		Execute "SineVarChange()"		Execute "SineBuilder()"	else		DoWindow /F SineBuilder	endifEndFunction SineVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	Execute "SineVarChange()"EndProc SineVarChange()	Variable i, j, first, last, totaldur, max, scale, rise, decay1, decay2, err	String notestr	String savDF	savDF=GetDataFolder(1)	SetDataFolder "root:DP_ADCDACcontrol"	Vars2Wave("sinedur","duration",3)	PauseUpdate	totaldur=0	i=0	do		totaldur+=duration[i]		i+=1	while(i<3)	Redimension /N=(totaldur/sintpb) SineDAC	Setscale /P x, 0, sintpb, "ms", SineDAC	Note /K SineDAC	ReplaceStringByKeyInWaveNote(SineDAC,"WAVETYPE","sinedac")	ReplaceStringByKeyInWaveNote(SineDAC,"TIME",time())	ReplaceStringByKeyInWaveNote(SineDAC,"SINEAMP",num2str(sineamp))	ReplaceStringByKeyInWaveNote(SineDAC,"SINEFREQ",num2str(sinefreq))	scale=1.37		// correct value is unique for each psc wave; there is a way to calculate this, but I forget	first=0	i=0	do		last=first+duration[i]		if (i==1)			SineDAC(first,last)=sineamp*sin(sinefreq*2*PI*(x-sinedur0)/1000)		else			SineDAC(first,last)=0		endif		first=last+sintpb		sprintf notestr, "SINEDUR%d", i		ReplaceStringByKeyInWaveNote(SineDAC,notestr,num2str(duration[i]))		i+=1	while(i<3)	ResumeUpdate	Duplicate /O SineDAC NewDAC	SetDataFolder savDFEndFunction EditSineWave(ctrlName,popNum,popStr) : PopupMenuControl	String ctrlName	Variable popNum	String popStr	String showstr	sprintf showstr, "ShowSineWave(\"%s\")", popStr	Execute showstrEndProc ShowSineWave(popstr)	String popstr	String keyword, keyval	Variable i	if (cmpstr(popstr,"_New_")==0)		sinedur0=10; sinedur1=50; sinedur2=10; sineamp=10; sinefreq=100; sintpb=0.01		SineVarChange()	else		keyval=StringByKeyInWaveNote("WAVETYPE",$popstr)		if (cmpstr(keyval,"sinedac")==0)			sineamp=NumberByKeyInWaveNote($popstr,"SINEAMP")			sinefreq=NumberByKeyInWaveNote($popstr,"SINEFREQ")			sintpb=deltax($popstr)			do				sprintf keyword, "SINEDUR%d", i				duration[i]=NumberByKeyInWaveNote($popstr,keyword)				i+=1			while(i<3)			Wave2Vars("duration", "sinedur", 3)			SineVarChange()		else			Abort("This is not a sine wave; choose another")		endif	endifEndFunction ViewDACButtonProc(ctrlName) : ButtonControl	String ctrlName	Execute "DACViewer()"EndFunction handleViewDacPopupSelection(ctrlName,itemNum,itemStr) : PopupMenuControl	String ctrlName	Variable itemNum	String itemStr	// Save current data folder, set to one we want.	String savedFolderName= GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol:		// Remove the current trace, put in the new one.	RemoveFromGraph /Z $"#0"	if ( cmpstr(itemStr,"(none)")!=0 )		AppendToGraph $itemStr		ModifyGraph grid(left)=1  // put the grid back	endif		// Restore the original data folder.	SetDataFolder savedFolderNameEnd//______________________Other DataPro PROCEDURES__________________________//// copy a list of variable names (with common base) into a waveFunction Wave2Vars(wbase,vbase,n)	String wbase, vbase	Variable n	Wave thewave=$wbase	String var, thevalue	do		sprintf var, "%s%d", vbase, n-1		NVAR thestring=$var		thestring=thewave[n-1]	//	print var, thestring, thewave[n-1]		n-=1	while(n>0)End// copy a list of variable names (with common base) into a waveFunction Wave2StringVars(wbase,vbase,n)	String wbase, vbase	Variable n	Wave /T thewave=$wbase	String var, thevalue	do		sprintf var, "%s%d", vbase, n-1		SVAR thestring=$var		thestring=thewave[n-1]	//	print var, thestring, thewave[n-1]		n-=1	while(n>0)End// copy a wave into a list of variable names (with common base)Function Vars2Wave(vbase,wbase,n)	String vbase, wbase	Variable n	String var	do		sprintf var, "%s%d", vbase, n-1		Wave varwave=$wbase		NVAR value=$var		varwave[n-1]=value		n-=1	while(n>0)EndFunction HandleADCBaseNameSetVariable(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		String savDF=GetDataFolder(1)	SetDataFolder root:DP_ADCDACcontrol	WAVE /T adcBaseName		Variable i=str2num(ctrlName[3])  // ADC channel index	adcBaseName[i]=varStr	SetDataFolder savDFEnd//Function ResetAxesProc(ctrlName,varNum,varStr,varName) : SetVariableControl//	String ctrlName//	Variable varNum//	String varStr//	String varName//	RescaleTopAxes()//End//Function CursorsCheckProc(ctrlName,checked) : CheckBoxControl//	String ctrlName//	Variable checked//	SVAR thiswave=thiswave//	PlaceCursors(thiswave)//End//_______________________Other DataPro FUNCTIONS___________________________//// returns 1 if option-cmd-dot pressedFunction HaltProcedures()	String s	s = KeyboardState("")	if (cmpstr(s[9], " ")==0)		// is spacebar pressed?		return 1	endif	return 0End// Compute Greatest Common Divisor// this is now included with Igor 5//Function GCD(a,b)//	Variable	a,b//	a=round(abs(a))		//+ive integers//	b=round(abs(b))//	if(a==0 %& b==0 )//		Abort	"Undefined when both numbers are zero"//	EndIf//	Variable rest//	If(b>a)		// swap so a > b//		rest=a//		a=b//		b=rest//	EndIf//	do//		rest=mod(a,b)//		a=b//		b=rest//	while(b!=0)//	Return a//End// Compute Least Common MultipleFunction LCM(a,b)	Variable	a,b	Return((a*b)/GCD(a,b))End// Remove a list of waves from the top graphFunction RemoveWaves(list,graph)	String list, graph	String theWave	Variable index=0	DoWindow /F $graph	do		theWave=GetStrFromList(list,index,";")		if (strlen(theWave)==0)			break		endif		RemoveFromGraph $theWave		index+=1	while(1)	//  loop until break aboveEnd